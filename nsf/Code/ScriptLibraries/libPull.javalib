<?xml version='1.0' encoding='utf-8'?>
<scriptlibrary name='libPull' xmlns='http://www.lotus.com/dxl' version='9.0'
 replicaid='C1257AC00076B554' hide='v3 v4strict' designerversion='8.5.3'>
<noteinfo noteid='306' unid='EA1165C499E7BA92852579B10073ED01' sequence='29'>
<created><datetime>20120227T160613,13-05</datetime></created>
<modified><datetime dst='true'>20130515T115640,00+02</datetime></modified>
<revised><datetime dst='true'>20130515T115639,99+02</datetime></revised>
<lastaccessed><datetime dst='true'>20130515T115639,99+02</datetime></lastaccessed>
<addedtofile><datetime>20121124T223638,57+01</datetime></addedtofile></noteinfo>
<updatedby><name>CN=Matt Vargish/O=Teamstudio</name><name>CN=UnpluggedUnrestricted/O=mvtest</name><name
>CN=Matt Vargish/O=Teamstudio</name><name>CN=UnpluggedUnrestricted/O=mvtest</name><name
>CN=Matt Vargish/O=Teamstudio</name><name>CN=UnpluggedUnrestricted/O=mvtest</name><name
>CN=Matt Vargish/O=Teamstudio</name><name>CN=UnpluggedUnrestricted/O=mvtest</name><name
>CN=Matt Vargish/O=Teamstudio</name><name>CN=Teamstudio Template Development/O=Teamstudio Inc.</name><name
>CN=Matt Vargish/O=Teamstudio</name><name>CN=UnpluggedUnrestricted/O=mvtest</name><name
>CN=Matt Vargish/O=Teamstudio</name><name>CN=UnpluggedUnrestricted/O=mvtest</name><name
>CN=Matt Vargish/O=Teamstudio</name><name>CN=UnpluggedUnrestricted/O=mvtest</name><name
>CN=Matt Vargish/O=Teamstudio</name><name>CN=UnpluggedUnrestricted/O=mvtest</name><name
>CN=Matt Vargish/O=Teamstudio</name><name>CN=UnpluggedUnrestricted/O=mvtest</name><name
>CN=Matt Vargish/O=Teamstudio</name><name>CN=UnpluggedUnrestricted/O=mvtest</name><name
>CN=Matt Vargish/O=Teamstudio</name><name>CN=Teamstudio Template Development/O=Teamstudio Inc.</name><name
>CN=Mark Leusink/O=LinQed</name></updatedby>
<wassignedby><name>CN=Mark Leusink/O=LinQed</name></wassignedby><code event='library'><javaproject
 class='JavaAgent.class' codepath='c:\Lotus\Notes852\Data'><java name='com/teamstudio/unplugged/libs/Base64Coder.java'>package com.teamstudio.unplugged.libs;

//Copyright 2003-2009 Christian d'Heureuse, Inventec Informatik AG, Zurich, Switzerland
//www.source-code.biz, www.inventec.ch/chdh
//
//This module is multi-licensed and may be used under the terms
//of any of the following licenses:
//
//EPL, Eclipse Public License, http://www.eclipse.org/legal
//LGPL, GNU Lesser General Public License, http://www.gnu.org/licenses/lgpl.html
//AL, Apache License, http://www.apache.org/licenses
//BSD, BSD License, http://www.opensource.org/licenses/bsd-license.php
//
//Please contact the author if you need another license.
//This module is provided "as is", without warranties of any kind.

/**
* A Base64 Encoder/Decoder.
* 
* &lt;p&gt;
* This class is used to encode and decode data in Base64 format as described in
* RFC 1521.
* 
* &lt;p&gt;
* Home page: &lt;a href="http://www.source-code.biz"&gt;www.source-code.biz&lt;/a&gt;&lt;br&gt;
* Author: Christian d'Heureuse, Inventec Informatik AG, Zurich, Switzerland&lt;br&gt;
* Multi-licensed: EPL/LGPL/AL/BSD.
* 
* &lt;p&gt;
* Version history:&lt;br&gt;
* 2003-07-22 Christian d'Heureuse (chdh): Module created.&lt;br&gt;
* 2005-08-11 chdh: Lincense changed from GPL to LGPL.&lt;br&gt;
* 2006-11-21 chdh:&lt;br&gt;
* &amp;nbsp; Method encode(String) renamed to encodeString(String).&lt;br&gt;
* &amp;nbsp; Method decode(String) renamed to decodeString(String).&lt;br&gt;
* &amp;nbsp; New method encode(byte[],int) added.&lt;br&gt;
* &amp;nbsp; New method decode(String) added.&lt;br&gt;
* 2009-07-16: Additional licenses (EPL/AL) added.&lt;br&gt;
* 2009-09-16: Additional license (BSD) added.&lt;br&gt;
*/

public class Base64Coder {

	// Mapping table from 6-bit nibbles to Base64 characters.
	private static char[] map1 = new char[64];
	static {
		int i = 0;
		for (char c = 'A'; c &lt;= 'Z'; c++)
			map1[i++] = c;
		for (char c = 'a'; c &lt;= 'z'; c++)
			map1[i++] = c;
		for (char c = '0'; c &lt;= '9'; c++)
			map1[i++] = c;
		map1[i++] = '+';
		map1[i++] = '/';
	}

	// Mapping table from Base64 characters to 6-bit nibbles.
	private static byte[] map2 = new byte[128];
	static {
		for (int i = 0; i &lt; map2.length; i++)
			map2[i] = -1;
		for (int i = 0; i &lt; 64; i++)
			map2[map1[i]] = (byte) i;
	}

	/**
	 * Encodes a string into Base64 format. No blanks or line breaks are
	 * inserted.
	 * 
	 * @param s
	 *            a String to be encoded.
	 * @return A String with the Base64 encoded data.
	 */
	public static String encodeString(String s) {
		return new String(encode(s.getBytes()));
	}

	/**
	 * Encodes a byte array into Base64 format. No blanks or line breaks are
	 * inserted.
	 * 
	 * @param in
	 *            an array containing the data bytes to be encoded.
	 * @return A character array with the Base64 encoded data.
	 */
	public static char[] encode(byte[] in) {
		return encode(in, in.length);
	}

	/**
	 * Encodes a byte array into Base64 format. No blanks or line breaks are
	 * inserted.
	 * 
	 * @param in
	 *            an array containing the data bytes to be encoded.
	 * @param iLen
	 *            number of bytes to process in &lt;code&gt;in&lt;/code&gt;.
	 * @return A character array with the Base64 encoded data.
	 */
	public static char[] encode(byte[] in, int iLen) {
		int oDataLen = (iLen * 4 + 2) / 3; // output length without padding
		int oLen = ((iLen + 2) / 3) * 4; // output length including padding
		char[] out = new char[oLen];
		int ip = 0;
		int op = 0;
		while (ip &lt; iLen) {
			int i0 = in[ip++] &amp; 0xff;
			int i1 = ip &lt; iLen ? in[ip++] &amp; 0xff : 0;
			int i2 = ip &lt; iLen ? in[ip++] &amp; 0xff : 0;
			int o0 = i0 &gt;&gt;&gt; 2;
			int o1 = ((i0 &amp; 3) &lt;&lt; 4) | (i1 &gt;&gt;&gt; 4);
			int o2 = ((i1 &amp; 0xf) &lt;&lt; 2) | (i2 &gt;&gt;&gt; 6);
			int o3 = i2 &amp; 0x3F;
			out[op++] = map1[o0];
			out[op++] = map1[o1];
			out[op] = op &lt; oDataLen ? map1[o2] : '=';
			op++;
			out[op] = op &lt; oDataLen ? map1[o3] : '=';
			op++;
		}
		return out;
	}

	/**
	 * Decodes a string from Base64 format.
	 * 
	 * @param s
	 *            a Base64 String to be decoded.
	 * @return A String containing the decoded data.
	 * @throws IllegalArgumentException
	 *             if the input is not valid Base64 encoded data.
	 */
	public static String decodeString(String s) {
		return new String(decode(s));
	}

	/**
	 * Decodes a byte array from Base64 format.
	 * 
	 * @param s
	 *            a Base64 String to be decoded.
	 * @return An array containing the decoded data bytes.
	 * @throws IllegalArgumentException
	 *             if the input is not valid Base64 encoded data.
	 */
	public static byte[] decode(String s) {
		return decode(s.toCharArray());
	}

	/**
	 * Decodes a byte array from Base64 format. No blanks or line breaks are
	 * allowed within the Base64 encoded data.
	 * 
	 * @param in
	 *            a character array containing the Base64 encoded data.
	 * @return An array containing the decoded data bytes.
	 * @throws IllegalArgumentException
	 *             if the input is not valid Base64 encoded data.
	 */
	public static byte[] decode(char[] in) {
		DecodeBufferReader buf = new DecodeBufferReader(in);
		//if (buf.getLength() % 4 != 0)
		//	throw new IllegalArgumentException(
		//			"Length of Base64 encoded input string is not a multiple of 4.");
		int oLen = (buf.getLength() * 3) / 4;
		byte[] out = new byte[oLen];
		
		int op = 0;
		while (buf.hasMore()) {
			int i0 = buf.getNext();
			int i1 = buf.getNext();
			int i2 = buf.hasMore() ? buf.getNext() : 'A';
			int i3 = buf.hasMore() ? buf.getNext() : 'A';
			if (i0 &gt; 127 || i1 &gt; 127 || i2 &gt; 127 || i3 &gt; 127)
				throw new IllegalArgumentException(
						"Illegal character in Base64 encoded data.");
			int b0 = map2[i0];
			int b1 = map2[i1];
			int b2 = map2[i2];
			int b3 = map2[i3];
			if (b0 &lt; 0 || b1 &lt; 0 || b2 &lt; 0 || b3 &lt; 0)
				throw new IllegalArgumentException(
						"Illegal character in Base64 encoded data.");
			int o0 = (b0 &lt;&lt; 2) | (b1 &gt;&gt;&gt; 4);
			int o1 = ((b1 &amp; 0xf) &lt;&lt; 4) | (b2 &gt;&gt;&gt; 2);
			int o2 = ((b2 &amp; 3) &lt;&lt; 6) | b3;
			out[op++] = (byte) o0;
			if (op &lt; oLen)
				out[op++] = (byte) o1;
			if (op &lt; oLen)
				out[op++] = (byte) o2;
		}
		return out;
	}

	static class DecodeBufferReader{
		private char[] buff = null;
		private int len = 0;
		private int curr = 0;
		
		DecodeBufferReader(char[] in){
			buff = in;
			len = in.length;
			while (len &gt; 0 &amp;&amp; (buff[len - 1] == '=' || '\r' == buff[len - 1] || '\n' == buff[len - 1]) ){
				len--;
			}
		}
		boolean hasMore(){
			return curr&lt;len;
		}
		int getLength(){
			return len;
		}
		int getOffset(){
			return curr;
		}
		int getNext(){
			int i = buff[curr++];
			while( curr &lt; len &amp;&amp; ('\r' == i || '\n' == i)){
				i = buff[curr++];
			}
			
			return i;
		}
				
	}
	// Dummy constructor.
	private Base64Coder() {
	}

} // end class Base64Coder</java><java name='com/teamstudio/unplugged/libs/DesignSelect.java'>package com.teamstudio.unplugged.libs;

import lotus.domino.Document;

public class DesignSelect {
    private WildcardPattern wc;
    private String formula;
    protected String name;
    protected String type;

    public String getType() {
        return type;
    }

    public DesignSelect(String type, String name, String formula) {
        super();
        this.formula = formula;
        this.name = name;
        this.type = type;
        wc = new WildcardPattern(name);
    }

    public String toString() {
        return "Design Select: type=" + type + "; name=" + name + "; formula=" + formula;
    }

    public boolean matches(Document note) {
        return true;
    }

    public WildcardPattern getWc() {
        return wc;
    }

    public String getName() {
        return name;
    }

    public String getFormula() {
        return formula;
    }

    public boolean hasFormula() {
        return (null != formula);
    }

    public boolean hasName() {
        return (null != name);
    }

}
</java><java name='com/teamstudio/unplugged/libs/FieldSelect.java'>package com.teamstudio.unplugged.libs;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

public class FieldSelect extends DesignSelect {
    private ArrayList children = new ArrayList();
    private boolean isInclude = true;
    private boolean isExcludeOnly = true;

    public boolean isExcludeOnly() {
        return isExcludeOnly;
    }

    public void setExcludeOnly(boolean isExcludeOnly) {
        this.isExcludeOnly = isExcludeOnly;
    }

    public String toString() {
        return "Field Select: type=" + type + "; name=" + name;
    }

    public boolean isInclude() {
        return isInclude;
    }

    public void setIsInclude(boolean isInclude) {
        this.isInclude = isInclude;
    }

    public FieldSelect(String type, String name, String formula) {
        super(type, name, formula);
        if (type.equals("exclude")) {
            this.isInclude = false;
        }
    }

    public void addChild(FieldSelect child) {
        children.add(child);
        if (child.isInclude()) {
            isExcludeOnly = false;
        }
    }

    public ArrayList getChildren() {
        return children;
    }

    private Map knownMatches = new HashMap();

    public void addKnownMatch(String itemName, boolean b) {
        if (!knownMatches.containsKey(itemName)) {
            Pull.writeDebug("Adding known item '" + itemName + "' as '" + b + "' to FieldSelect '" + this + "' ");
            knownMatches.put(itemName, new Boolean(b));
        }
    }

    public boolean getKnownMatch(String itemName) {
        if (knownMatches.containsKey(itemName)) {
            return ((Boolean)knownMatches.get(itemName)).booleanValue();
        }
        else {
            throw new TeamstudioException(9999, "No known match for '" + itemName + "' -- call hasKnownMatch first!"); // TODO err
                                                                                                                       // number
        }
    }

    public boolean hasKnownMatch(String itemName) {
        return knownMatches.containsKey(itemName);
    }

}
</java><java name='com/teamstudio/unplugged/libs/IReplicationNote.java'>package com.teamstudio.unplugged.libs;

import lotus.domino.Database;
import lotus.domino.Document;
import lotus.domino.DxlExporter;
import lotus.domino.NotesException;
import lotus.domino.Session;

public interface IReplicationNote {

    public static final int TYPE_UNKNOWN = 0;
    public static final int TYPE_DATA = 1;
    public static final int TYPE_DESIGN = 2;
    public static final int TYPE_DELETION = 3;

    public abstract boolean hasError();

    public abstract String getTypeName();

    public abstract String toString();

    // public abstract boolean matchesSelectFormula(Session session, String sFmla);

    public abstract boolean loadDoc(Session session, Database db) throws NotesException;

    public abstract boolean wantNote(boolean skipPurges) throws NotesException;

    public abstract String getNoteDxl(Session session, DxlExporter ex, Logger log) throws Exception;

    public abstract void releaseDoc() throws NotesException;

    public abstract boolean isNoteLoaded();

    public abstract int getType();

    public abstract void setType(int type);

    public abstract String getId();

    public abstract void setId(String id);

    public abstract String getNoteDescription();

    public abstract boolean wantDesignNoteType(Document Note) throws NotesException;

}</java><java name='com/teamstudio/unplugged/libs/Logger.java'>package com.teamstudio.unplugged.libs;

import java.util.Vector;

import lotus.domino.ColorObject;
import lotus.domino.Database;
import lotus.domino.Document;
import lotus.domino.Item;
import lotus.domino.NotesException;
import lotus.domino.RichTextItem;
import lotus.domino.RichTextStyle;
import lotus.domino.Session;

public class Logger {
    private boolean m_fLogOpen;
    private boolean m_fLogOpenAttempted;
    private Document m_docLog;
    private Database m_dbLog;
    private RichTextItem m_rti;
    private String m_sType;
    private RichTextStyle stB;
    private RichTextStyle stP;
    private Session s;
    private boolean m_fHasErrors;
    private boolean m_fHasWarnings;
    private String m_sUser;
    private String m_sPin;
    private String m_targetDatabase;
    private String m_sFirstNoteId;
    private long m_runTimeMS = 0;
    private String m_testid;
    public static final int LOG_ON_ERROR_ONLY = 1;
    public static final int LOG_REQUEST = 2;
    public static final int LOG_RESPONSE = 4;
    public static final int LOG_DEBUG = 8;
    public static final int LOG_ERROR_NOTE = 4096;
    private StringBuilder sbDebug;
    private String unpConfigSubdir = null;
    private String m_sLastNoteId;
    private String m_sNextNoteId;
    private int m_clientProtocolVersion = 0;
	private int m_clientDbFileFormat;
	private String m_logDbServer;
	private String m_logDbPath;
	private String m_LoggedErrorNoteId;

	
    public long getRunTimeMS() {
        return m_runTimeMS;
    }

    public void setRunTimeMS(long runTimeMS) {
        this.m_runTimeMS = runTimeMS;
    }

    public String getFirstNoteId() {
        return m_sFirstNoteId;
    }

    public void setFirstNoteId(String firstNoteId) {
        this.m_sFirstNoteId = firstNoteId;
    }

    public String getLastNoteId() {
        return m_sLastNoteId;
    }

    public void setLastNoteId(String lastNoteId) {
        this.m_sLastNoteId = lastNoteId;
    }

    public String getNextNoteId() {
        return m_sNextNoteId;
    }

    public void setNextNoteId(String nextNoteId) {
        this.m_sNextNoteId = nextNoteId;
    }

    public Logger(String type, Session s) throws NotesException {
        super();
        m_sType = type;
        this.s = s;
        
        //set up the path to the log db
        if (!s.isOnServer()) {
            // when debugging we want the server where the config is which should be
            // that gotten through the debug versions of AgentContext
            m_logDbServer = s.getAgentContext().getCurrentDatabase().getServer();
        }
        String replpath = s.getAgentContext().getCurrentDatabase().getFilePath().replace('\\', '/');
        if (-1 != replpath.indexOf('/')) {
            unpConfigSubdir = replpath.substring(0, replpath.lastIndexOf('/') + 1);
            m_logDbPath = unpConfigSubdir + "UnpluggedLog.nsf";
        }
        else {
        	m_logDbPath = "UnpluggedLog.nsf";
        }
        
        
        
    }
   
    private void LoadLogDb() {
        try {
            m_dbLog = s.getDatabase(m_logDbServer, m_logDbPath, true);


            if (m_dbLog.isOpen()) {
                m_docLog = m_dbLog.createDocument();
                if (null != m_docLog) {
                    m_docLog.replaceItemValue("Form", "MessageLog");
                    m_docLog.replaceItemValue("Type", m_sType);
                    m_rti = m_docLog.createRichTextItem("Message");
                    CreateStyles();
                    m_rti.appendStyle(stP);
                    m_fLogOpen = true;
                }
            }
        }
        catch (NotesException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        finally {
            m_fLogOpenAttempted = true;
        }
    }

    void dispose() {
        if (m_fLogOpen) {
            try {
                m_rti.compact();

                // status
                int nStatus = 0;
                if (m_fHasWarnings) {
                    nStatus = 1;
                }
                if (m_fHasErrors) {
                    nStatus = nStatus + 2;
                }
                m_docLog.replaceItemValue("Status", Integer.valueOf(nStatus));
                // user &amp; pin
                m_docLog.replaceItemValue("UserName", m_sUser);
                m_docLog.replaceItemValue("Pin", m_sPin);
                m_docLog.replaceItemValue("Database", m_targetDatabase);
                m_docLog.replaceItemValue("FirstNoteID", m_sFirstNoteId);
                m_docLog.replaceItemValue("LastNoteID", m_sLastNoteId);
                m_docLog.replaceItemValue("NextNoteID", m_sNextNoteId);
                m_docLog.replaceItemValue("RunTimeMS", new Long(m_runTimeMS));
                m_docLog.replaceItemValue("ClientProtocolVersion", new Integer(m_clientProtocolVersion));
                m_docLog.replaceItemValue("ServerProtocolVersion", new Integer(Pull.SERVER_PROTOCOL_VERSION));
                m_docLog.replaceItemValue("ClientDbFileFormat", new Integer(m_clientDbFileFormat));
                
                if (null!=m_LoggedErrorNoteId){
                	m_docLog.replaceItemValue("LoggedErrorNoteId", m_LoggedErrorNoteId);
                }
                if (null != m_testid) {
                    m_docLog.replaceItemValue("TestId", m_testid);
                }
                m_docLog.save(true, true);
                m_docLog.recycle();
                m_dbLog.recycle();
            }
            catch (NotesException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

        }
    }

    public String getTargetDatabase() {
        return m_targetDatabase;
    }

    public void setTargetDatabase(String database) {
        m_targetDatabase = database;
    }
    
    public String getLogDbApiPath() throws TeamstudioException, NotesException{
    	if(null==m_logDbServer)
    	{
    		return m_logDbPath;
    	}
    	if("".equals(m_logDbServer))
    	{
    		return m_logDbPath;
    	}
    	return m_logDbServer + "!!" + m_logDbPath;
    }

    public void DebugWrite(String sMsg) {
        if (m_fLogOpen) {
            Write(sMsg);
        }
        else {
            if (null == sbDebug) {
                sbDebug = new StringBuilder();
            }
            sbDebug.append("\n\r" + sMsg);
        }
    }

    void DebugCommit() {
        AddHeader("Debugging Messages");
        if (null != unpConfigSubdir) {
            Write("Unplugged Data Synchronizer Directory: " + unpConfigSubdir);
        }
        if (null != sbDebug) {
            Write(sbDebug.toString());
        }
    }

    void Write(String sMsg) {
        if ((!m_fLogOpenAttempted)) {
            LoadLogDb();
        } // only if first call
        if (m_fLogOpen) {
            try {
                m_rti.addNewLine(1);
                m_rti.appendText(sMsg);
            }
            catch (NotesException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }

    void AddHeader(String sHeaderName) {
        if ((!m_fLogOpenAttempted)) {
            LoadLogDb();
        } // only if first call
        if (m_fLogOpen) {
            try {
                m_rti.addNewLine(2);
                m_rti.appendStyle(stB);
                m_rti.appendText(sHeaderName);
                m_rti.appendStyle(stP);
                m_rti.addNewLine(1);
            }
            catch (NotesException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

        }
    }

    void LogRequestHeaders(Document docRequest) {
        if ((!m_fLogOpenAttempted)) {
            LoadLogDb();
        } // only if first call
        if (m_fLogOpen) {

            Vector items;
            try {
                items = docRequest.getItems();
                for (int j = 0; j &lt; items.size(); j++) {
                    Item item = (Item)items.elementAt(j);
                    if (!item.getName().startsWith("REQUEST_CONTENT")) {
                        m_rti.addNewLine(1);
                        m_rti.appendText(item.getName() + "=" + item.getText());
                    }
                }
            }
            catch (NotesException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }

    private void CreateStyles() throws NotesException {
        stB = s.createRichTextStyle();
        stP = s.createRichTextStyle();

        stP.setFontSize(9);
        stP.setBold(RichTextStyle.NO);
        stP.setColor(RichTextStyle.COLOR_BLACK);

        ColorObject color = s.createColorObject();
        stB.setBold(RichTextStyle.YES);
        stB.setColor(color.setRGB(0, 90, 160));
        stB.setFontSize(10);
    }

    public boolean getHasErrors() {
        return m_fHasErrors;
    }

    public void setHasErrors(boolean hasErrors) {
        m_fHasErrors = hasErrors;
    }

    public boolean getHasWarnings() {
        return m_fHasWarnings;
    }

    public void setHasWarnings(boolean hasWarnings) {
        m_fHasWarnings = hasWarnings;
    }

    public String getUser() {
        return m_sUser;
    }

    public void setUser(String user) {
        m_sUser = user;
    }

    public String getPin() {
        return m_sPin;
    }

    public void setPin(String pin) {
        m_sPin = pin;
    }

    public String getTestId() {
        return m_testid;
    }

    public void setTestId(String testId) {
        m_testid = testId;
    }
    
    public int getClientProtocolVersion() {
        return m_clientProtocolVersion;
    }

    public void setClientProtocolVersion(int clientProtocolVers) {
    	m_clientProtocolVersion = clientProtocolVers;
    }

	public void setClientDbFormat(int clientCurrentFileFormat) {
		m_clientDbFileFormat = clientCurrentFileFormat;
	}
	
	public int getClientDbFormat() {
		return m_clientDbFileFormat;
	}

	public void setCapturedErrorNoteID(String errNoteId) {
		m_LoggedErrorNoteId = 	errNoteId;
	}

}
</java><java name='com/teamstudio/unplugged/libs/PVObjectFactory.java'>package com.teamstudio.unplugged.libs;

public class PVObjectFactory {
    private static PVObjectFactory _this;
    private static int protocolVers;
    private static int currentFormat;
    public int test = 0;

    private PVObjectFactory(int protocolVersion, int currentFileFormat) {
        protocolVers = protocolVersion;
        currentFormat = currentFileFormat;

        if (test == 1) {
            protocolVers = 1;
            currentFormat = 1;
        }
    }

    public static PVObjectFactory getInstance(int protocolVersion, int currentFileFormat) {
        if (_this == null) {
            _this = new PVObjectFactory(protocolVersion, currentFileFormat);
        }
        return _this;
    }

    public static PVObjectFactory getInstance() {
        if (1 &gt; protocolVers) {
            throw new TeamstudioException(9999, "Protocol Version not set");
        }
        return _this;
    }

    public IReplicationNote createReplicationNote(String IDWithTypePrefix, SessionInfo SI) {
        if (2 &gt; protocolVers) {
            return new com.teamstudio.unplugged.libs.pv1.ReplicationNote(IDWithTypePrefix, SI);
        }
        else if (2 == protocolVers) {
            return new com.teamstudio.unplugged.libs.pv2.ReplicationNote(IDWithTypePrefix, SI, currentFormat);
        }
        else if (3 == protocolVers) {
            return new com.teamstudio.unplugged.libs.pv3.ReplicationNote(IDWithTypePrefix, SI, currentFormat);
        }
        else {
            return new com.teamstudio.unplugged.libs.pv4.ReplicationNote(IDWithTypePrefix, SI, currentFormat);
        }
    }

    public static int getTargetFileFormat() {
        // return targetFormat;
        if (2 &gt; protocolVers) {
            return 1;
        }
        else if (4 &gt; protocolVers) { // pv 2, 3 are format 2
            return com.teamstudio.unplugged.libs.pv2.ReplicationNote.FILE_FORMAT;
        }
        else {
            return com.teamstudio.unplugged.libs.pv4.ReplicationNote.FILE_FORMAT;
        }

    }

    public int getCurrentClientFormat() {
        return currentFormat;
    }

}
</java><java name='com/teamstudio/unplugged/libs/Pull.java'>package com.teamstudio.unplugged.libs;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Vector;
import java.util.zip.GZIPOutputStream;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import lotus.domino.Agent;
import lotus.domino.AgentBase;
import lotus.domino.AgentContext;
import lotus.domino.Database;
import lotus.domino.DateTime;
import lotus.domino.Document;
import lotus.domino.DocumentCollection;
import lotus.domino.DxlExporter;
import lotus.domino.NoteCollection;
import lotus.domino.NotesException;
import lotus.domino.Session;

import org.xml.sax.SAXException;

import com.sun.org.apache.xml.internal.security.exceptions.Base64DecodingException;
import com.sun.org.apache.xml.internal.security.utils.Base64;

public class Pull {

    public static final int SERVER_PROTOCOL_VERSION = 4;

    public static final String ACTION_TRIGGER_FIELD = "UnpActionTrigger";
    public static final String ACTION_LOG_ERR_NOTE = "LogErrNote";

    private static final String DATABASE_CLOSE_TAG = "&lt;/database&gt;";
    private static final int MAX_BUFFER_DEFAULT = (256 * 1024);
    private static final int MAX_PULL_TIME_DEFAULT = 45000;
    private static final int TEST_DELAY_DEFAULT = 0; // MUST remain 0
    private boolean m_fHasErrors;
    private boolean m_fHasWarnings;
    private AgentBase m_ab;
    private static Logger m_log = null;
    private boolean m_fLogErrOnly = true;
    private static boolean m_fLogDebug = false;
    private int m_nLogLevel = 0;
    int max_buffer = MAX_BUFFER_DEFAULT;

    public static void writeDebug(String msg) {
        if (m_fLogDebug) {
            m_log.DebugWrite(msg);
        }
    }

    public void DoPull(AgentBase agentbase) {
        String strOutput = "";
        Database db = null;
        Document doc = null;
        Session session = null;
        params = null;
        String sPin = "";
        PrintWriter pw = null;
        boolean compress = false;
        boolean reachedMaxChunk = false;
        int sbLength = 0;
        int sbLengthChunkOverhead = 0;
        IReplicationNote repnote = null;
        AgentContext agentContext = null;
        SessionInfo si = null;
        try {

            long startmillis = System.currentTimeMillis();
            m_ab = agentbase;
            session = m_ab.getSession();
            agentContext = session.getAgentContext();
            pw = m_ab.getAgentOutput();

            int cntSent = 0;
            int cntSkipped = 0;

            doc = agentContext.getDocumentContext();
            String qs = doc.getItemValueString("QUERY_STRING");

            params = parseQueryString(session, qs);
            compress = "1".equals(params.get("compress"));

            // SET UP THE MUST-HAVE HEADERS (IF WE ERR BEFORE PULL SPECIFIC HEADERS WE STILL NEED THESE):
            pw.println("Content-Type: text/xml; charset=utf-8");
            if (compress) {
                pw.println("X-TMS-Encoding: gzip,base64");
            }

            String sProtocolVersion = doc.getItemValueString("HTTP_X_TMS_PROTOCOL");
            int protocolVersion = 1; // no version default
            int clientProtocolVersion = 1;
            if (0 &lt; sProtocolVersion.length()) {
                clientProtocolVersion = Integer.valueOf(sProtocolVersion).intValue();
                if (SERVER_PROTOCOL_VERSION &lt; clientProtocolVersion) {
                    protocolVersion = SERVER_PROTOCOL_VERSION;
                }
                else {
                    protocolVersion = clientProtocolVersion;
                }
            }

            String sFileFormat = doc.getItemValueString("HTTP_X_TMS_FILEFORMAT");
            // int fileFormat = 1; // no version default
            int clientCurrentFileFormat = 1;
            if (0 &lt; sFileFormat.length()) {
                clientCurrentFileFormat = Integer.valueOf(sFileFormat).intValue();
            }

            // we need to set up the factory now so we can return the target format...
            PVObjectFactory.getInstance(protocolVersion, clientCurrentFileFormat); // set up the factory

            boolean forceUpgrade =
                    ((!"0".equals(params.get("sinceJava"))) &amp;&amp; (clientCurrentFileFormat &lt; PVObjectFactory.getTargetFileFormat()));
            // boolean forceUpgrade = ( (clientCurrentFileFormat &lt; PVObjectFactory.getTargetFileFormat()) );

            String server = "";
            String dbPath = (String)params.get("db");
            sPin = (String)params.get("device");
            String srcID = (String)params.get("srcid");

            logSetup(session, "Pull");

            // overrides for automated testing
            // max buffer may also be set when setting read in logSetup.
            max_buffer = (null == params.get("maxb")) ? max_buffer : Integer.valueOf((String)params.get("maxb")).intValue();
            int max_time =
                    (null == params.get("maxt")) ? MAX_PULL_TIME_DEFAULT : Integer.valueOf((String)params.get("maxt")).intValue();
            int test_delay =
                    (null == params.get("testdelay")) ? TEST_DELAY_DEFAULT
                            : Integer.valueOf((String)params.get("testdelay")).intValue();
            int test_delay_on_load =
                    (null == params.get("testdelayload")) ? TEST_DELAY_DEFAULT : Integer.valueOf(
                            (String)params.get("testdelayload")).intValue();

            if (0 &lt; m_nLogLevel) {
                m_log.setPin(sPin);
                m_log.setTargetDatabase(dbPath);
                m_log.setClientProtocolVersion(clientProtocolVersion);
                m_log.setClientDbFormat(clientCurrentFileFormat);
                if (params.containsKey("testid")) {
                    m_log.setTestId((String)params.get("testid"));
                }
                if (m_fLogDebug) {
                    Runtime rt = Runtime.getRuntime();
                    m_log.DebugWrite("JVM Memory:  " + "  Total:" + rt.totalMemory() + ";  Max:" + rt.maxMemory() + ";  Free:"
                            + rt.freeMemory());
                    m_log.DebugWrite("Max Buffer Size = " + max_buffer);

                    if (clientProtocolVersion &gt; protocolVersion) {
                        m_log.DebugWrite("***Server does not support requested protocol version, using highest server protocol version: "
                                + protocolVersion);
                    }
                    m_log.DebugWrite("Client protocol version: " + clientProtocolVersion + ";  Response protocol version: "
                            + protocolVersion);

                    m_log.DebugWrite("Client apps file format is: " + clientCurrentFileFormat);
                    if (forceUpgrade) {
                        m_log.DebugWrite("Protocol file format is " + PVObjectFactory.getTargetFileFormat()
                                + ". App will be upgraded.");
                    }
                }
            }

            if (dbPath.contains("!!")) {
                String[] temp = dbPath.split("!!");
                server = temp[0];
                dbPath = temp[1];
            }

            String baseDirectory = "";
            if (params.containsKey("basedir")) {
                baseDirectory = (String)params.get("basedir");
                if (baseDirectory.indexOf('\\') &gt; 0) {
                    baseDirectory = baseDirectory.replace("\\", "/");
                }
                baseDirectory += baseDirectory.endsWith("/") ? "" : "/";
                if (m_fLogDebug) {
                    m_log.DebugWrite("Base directory specified. Using path: " + dbPath);
                }
            }
            targetDbPath = baseDirectory + dbPath;
            targetDbApiPath = (0 != server.length()) ? server + "!!" + targetDbPath : targetDbPath;

            if (!session.isOnServer()) {
                // if we're not on server, this should still be "" if in notes but otherwise this helps debugging
                db = session.getDatabase(session.getAgentContext().getCurrentDatabase().getServer(), targetDbPath);
            }
            else {
                db = session.getDatabase(server, targetDbPath);
            }

            if (null == sPin) {
                throw new TeamstudioException(ERR_NO_DEVICE, ERR_NO_DEVICE_MSG);
            }
            if (null == db) {
                throw new TeamstudioException(ERR_DB_NOT_OPEN, ERR_DB_NOT_OPEN_MSG);
            }
            if (!db.isOpen()) {
                throw new TeamstudioException(ERR_DB_NOT_OPEN2, ERR_DB_NOT_OPEN_MSG);
            }

            DxlExporter ex = session.createDxlExporter();
            // some of these are toggled in ReplicationNote exportDxl but should be reset to these defaults...
            ex.setOutputDOCTYPE(false);
            ex.setOmitMiscFileObjects(true);
            ex.setOmitOLEObjects(true);
            ex.setOmitRichtextAttachments(true);
            ex.setOmitRichtextPictures(true);
            ex.setForceNoteFormat(false);
            ex.setRichTextOption(DxlExporter.DXLRICHTEXTOPTION_RAW);

            StringBuilder sb = new StringBuilder();

            DateTime pullTime = null;

            if (m_fLogDebug) {
                if (forceUpgrade) {
                    m_log.DebugWrite("Creating session with flags to Upgrade File Format");
                }
            }

            si = SessionInfo.getInstance();
            if (!si.loadSession(session, agentContext, targetDbApiPath, params, forceUpgrade)) {
                if (m_fLogDebug) {
                    m_log.DebugWrite("Previous synchronization session failed to load (session may have expired or completed).  Starting new session.");
                }
                params.put("si", "NTO");
                if (!si.loadSession(session, agentContext, targetDbApiPath, params, forceUpgrade)) {
                    throw new TeamstudioException(ERR_CANT_CREATE_SESS, ERR_CANT_CREATE_SESS_MSG);
                }
            }

            if (si.isNew()) {
                si.setOpeningDxlDbTag(getDatabaseOpenDxl(db, session, ex));
                // repl formulas, stored by SI
                loadDesignReplSelection(session, db, si, ex);
                loadFieldReplSelection(session, db, si, ex);
                si.loadDbConfig(m_ab.getSession(), m_ab.getSession().getAgentContext().getCurrentDatabase(), server, dbPath, srcID);
                // parse post data and save device unids if posted
                String postDataRaw = this.getPostData(doc);
                if (null == postDataRaw) {
                    if (m_fLogDebug) {
                        m_log.DebugWrite("No device UNIDs posted...");
                    }
                }
                else {
                    Map postData = parsePostData(postDataRaw);
                    if (null != postData) {
                        if (postData.containsKey("deviceUnids")) {
                            String sDeviceUnids = (String)postData.get("deviceUnids");
                            if (m_fLogDebug) {
                                m_log.DebugWrite("Received UNID list from device, length: " + sDeviceUnids.length());
                            }
                            si.loadDeviceUnids(sDeviceUnids);
                        }
                    }
                }

                if (si.hasFieldSelect()) {
                    if (m_fLogDebug) {
                        m_log.DebugWrite("Field selection enabled.");
                    }
                    if (4 &gt; protocolVersion) {
                        // no support for field select, log warning
                        if (m_fLogDebug) {
                            m_log.DebugWrite("Field-level replication enabled but not supported on older client, ignoring....");
                        }
                    }
                    else {
                        if (forceUpgrade &amp;&amp; (3 &gt; clientCurrentFileFormat)) {
                            // we support field selection, we need to update the data so
                            // we process field selection
                            si.forceFieldUpgrade();
                            if (m_fLogDebug) {
                                m_log.DebugWrite("Forcing upgrade of documents to reload data after Field Selection change...");
                            }
                        }
                        else if (si.isFieldSelectUpdated()) { // pv4+ we send docs again if field select
                                                              // updated
                            // TODO: Can we avoid sending design again&gt;&gt;&gt;????
                            si.forceFieldUpgrade();
                            if (m_fLogDebug) {
                                m_log.DebugWrite("Forcing upgrade of documents to reload data after Field Selection change...");
                            }
                        }
                    }
                }
                si.save(); // make sure we keep these...
                // create our list of ids on the session document... resaves
                loadNoteIDs(session, agentContext, si);
                if (0 != test_delay_on_load) {
                    Thread.sleep(test_delay_on_load);
                }
            }

            sbLengthChunkOverhead = si.getOpeningDxlDbTag().getBytes().length + 300; // 300 to account for sessinfo and pullinfo
                                                                                     // tags
            sbLength = sbLengthChunkOverhead;

            if (m_fLogDebug) {
                m_log.DebugWrite("Total notes " + si.getCount() + " (including " + si.getCountDeleted() + " deletions)");
                m_log.DebugWrite("Chunking support? " + si.SupportsChunking() + "; " + "Starting offset: " + si.getOffset());
                if (si.hasSelect()) {
                    m_log.DebugWrite("Found sync selection formula: " + si.getSelectFormula());
                }
            }

            boolean wantNote = false;
            String noteXml = "";
            int noteXmlLength = 0;

            repnote = si.getNextReplicationNote();
            int startAtNote = 0;

            // SET UP THE SPECIFIC HEADERS:
            pw.println("X-TMS-Protocol: " + protocolVersion);
            pw.println("X-TMS-FileFormat: " + PVObjectFactory.getTargetFileFormat());
            if (si.isFieldSelectUpdated()) {
                pw.println("X-TMS-ForceUpdate: 1"); // tell client to force-update all notes...
            }
            pw.println();

            // START PROCESSING NOTES
            if (null != repnote) {
                startAtNote = si.getCountProcessed(); // now that it's processed the first...
                if (0 &lt; m_nLogLevel) {
                    m_log.setFirstNoteId(repnote.getId());
                    m_log.DebugWrite("Starting processing at note " + startAtNote);
                }
            }

            while ((null != repnote) &amp;&amp; (!reachedMaxChunk)) {

                if ((max_time &lt; (System.currentTimeMillis() - startmillis))) { // TIME'S UP
                    reachedMaxChunk = true;
                    si.resetToLastOffset();
                    if (0 &lt; m_nLogLevel) {
                        m_log.setNextNoteId(repnote.getId());
                        if (m_fLogDebug) {
                            m_log.DebugWrite("Reached max TIME for pull; first omitted note = " + repnote);
                        }
                    }
                    repnote = null;

                }
                else { // not timed out yet

                    // For testing timeouts. Occurs after the test for timeout, because in reality
                    // we will only time out when a loading ids took too long
                    // (so we returned nothing first pull, but okay, start over on next pull)
                    // or when opening a particular doc takes longer than the timeout
                    // (in which case we will send it below, and timeout when we return top of loop)
                    if (0 != test_delay) {
                        Thread.sleep(test_delay);
                    }

                    if (!repnote.loadDoc(session, db)) {
                        // note was inaccessible, but will not meet wantNote test; will output in log below if debugging msgs
                        // enabled
                        // do nothing.
                    }

                    wantNote = repnote.wantNote(si.isSkipPurges());

                    // Export it, either as DXL (transformed) or as purge
                    if (wantNote) {
                        if (m_fLogDebug) {
                            noteXml = repnote.getNoteDxl(session, ex, m_log);
                        }
                        else {
                            noteXml = repnote.getNoteDxl(session, ex, null);
                        }
                    }

                    repnote.releaseDoc();

                    // ADD XML IF ROOM...
                    if (wantNote) {

                        noteXmlLength = noteXml.getBytes("UTF8").length;

                        // TOO BIG TO SEND
                        if ((si.SupportsChunking() &amp;&amp; ((sbLengthChunkOverhead + noteXmlLength) &gt; max_buffer))) { // single note too
                                                                                                                 // big

                            // we've found a note that's too big to send
                            cntSkipped++;
                            if (m_fLogDebug) {
                                m_fHasWarnings = true;
                                m_log.DebugWrite("*** Note too large to sync!: " + repnote + " Size=" + noteXmlLength
                                        + " Chunk Overhead=" + sbLengthChunkOverhead);
                            }
                            repnote = si.getNextReplicationNote();

                            // CHUNK IS FULL
                        }
                        else if ((si.SupportsChunking() &amp;&amp; ((sbLength + noteXmlLength) &gt; max_buffer))) { // full
                            // done with chunk
                            reachedMaxChunk = true;
                            si.resetToLastOffset();
                            if (0 &lt; m_nLogLevel) {
                                m_log.setNextNoteId(repnote.getId());
                                if (m_fLogDebug) {
                                    m_log.DebugWrite("Reached max in chunked pull; first omitted note = " + repnote);
                                }
                            }
                            repnote = null;

                        }
                        else { // add xml here if 1) chunk not full or 2) chunking not supported...
                            sbLength += noteXmlLength;
                            sb.append(noteXml);
                            cntSent++; // this is the number of notes we actually are sending so incr only here.
                            if (0 &lt; m_nLogLevel) {
                                m_log.setLastNoteId(repnote.getId());
                                if (m_fLogDebug) {
                                    if (IReplicationNote.TYPE_DESIGN == repnote.getType()) {
                                        // log design note inclusion only to aid in troubleshooting.
                                        m_log.DebugWrite("Including note: " + repnote);
                                    }
                                }
                            }
                            repnote = si.getNextReplicationNote();
                        }

                    }
                    else {

                        // not sending note, just get next
                        cntSkipped++;
                        // don't normally log notes that missed selection.
                        // if (m_fLogDebug) {
                        // m_log.DebugWrite("*Omitting note: " + repnote + " cnt= " + cntSkipped);
                        // }
                        repnote = si.getNextReplicationNote();

                    }

                } // not timed out yet
            } // while

            if (m_fLogDebug) {
                m_log.DebugWrite("Sent " + cntSent + " documents. (" + si.getCountProcessed() + " processed in pull, " + cntSkipped
                        + " omitted).");
                if (si.isForceUpgrade()) {
                    m_log.DebugWrite("Upgrade of database skipped existing notes that did not need resend: Data: "
                            + si.getCntUpgradeSkippedData() + "; Design: " + si.getCntUpgradeSkippedDesign());
                }
            }

            String replInfo =
                    "&lt;tms:replicationinfo total='" + si.getCount() + "' firstprocessed='" + startAtNote + "' lastprocessed='"
                            + si.getCountProcessed() + "' sent='" + cntSent + "' omitted='" + cntSkipped + "' /&gt;";

            strOutput += si.getOpeningDxlDbTag();

            String xmlEndTags = "";
            if (reachedMaxChunk) {
                xmlEndTags += "&lt;tms:sessioninfo&gt;" + si.getSessionInfoTag() + "&lt;/tms:sessioninfo&gt;" + "";
            }
            else {
                pullTime = si.getUntilTime();
                if (null == pullTime) {
                    throw new TeamstudioException(ERR_NO_PULL_TIME, ERR_NO_PULL_TIME_MSG);
                }
                String pullTimeText = convertDateTimeToDxlText(session, pullTime);
                xmlEndTags += "&lt;tms:pullTime&gt;" + pullTimeText + "&lt;/tms:pullTime&gt;";
                si.markForDeletion();
            }

            // do not use si after here it may be marked for deletion...

            sb.append(xmlEndTags + DATABASE_CLOSE_TAG);

            strOutput += replInfo + sb.toString();

            // note: if we error after this next line we need to be aware we've
            // probably started to write an xml doc to out

            pw.print(compressOutput(strOutput, compress));
            pw.flush();
            long runTimeMS = System.currentTimeMillis() - startmillis;

            if (0 &lt; m_nLogLevel) {
                m_log.setRunTimeMS(runTimeMS);
            }

        }
        catch (Exception e) {
            m_fHasErrors = true;
            int errorCode = 0;
            String emsg = "";
            if (e instanceof TeamstudioException) {
                errorCode = ((TeamstudioException)e).getErrorCode();
                emsg = e.getMessage();
            }
            else if (e instanceof NotesException) {
                errorCode = ((NotesException)e).id;
                emsg = ((NotesException)e).text;
            }
            else {
                errorCode = 9999;
                emsg = e.getMessage();
                if (null == emsg) {
                    emsg = e.getClass().getName() + " (null error message)";
                }
            }

            String sError =
                    "&lt;?xml version='1.0' encoding='utf-8' ?&gt;" + "&lt;tms:unplugged xmlns:tms='http://www.teamstudio.com/unplugged'&gt;"
                            + "&lt;tms:error number='" + errorCode + "'  message='" + xmlEscape(emsg) + "' "
                            + ((null != repnote) ? "activenote='" + repnote.getId() + "' " : "") + " /&gt;" + "&lt;/tms:unplugged&gt;";

            strOutput += sError;
            try {
                pw.println(compressOutput(strOutput, compress));
                pw.flush();
            }
            catch (Exception e1) {
                e1.printStackTrace();
            }
            if (m_fLogDebug) {
                m_log.DebugWrite("Error " + errorCode + ":  " + emsg);
                if (null != repnote) {
                    m_log.DebugWrite("[last note:" + repnote + "]");
                    if ((Logger.LOG_ERROR_NOTE &amp; m_nLogLevel) == Logger.LOG_ERROR_NOTE) {
                        try {
                            logErrorNote(session, agentContext, si, repnote.getId());
                            System.out.println("shite");
                        }
                        catch (Exception eLogErrNote) {
                            m_log.DebugWrite("Error logging active note: " + eLogErrNote.getMessage());
                        }
                    }
                }
                StringBuilder sbStack = new StringBuilder();
                StackTraceElement[] ste = e.getStackTrace();
                for (int i = 0; i &lt; ste.length; i++) {
                    sbStack.append(ste[i]);
                    sbStack.append("\r\n");
                }
                m_log.DebugWrite(sbStack.toString());
            }
        }
        finally {

            logCommit(session, doc, strOutput);
            try {
                if (null != session) {
                    session.recycle();
                }
            }
            catch (NotesException e) {
                e.printStackTrace();
            }

        }
    }

    private Map parsePostData(String postData) {
        Map answer = new HashMap();
        String params[] = postData.split("&amp;");

        for (int i = 0; i &lt; params.length; ++i) {
            String temp[] = params[i].split("=");
            answer.put(temp[0], temp.length == 1 ? "" : temp[1]);
        }
        return answer;
    }

    private static final String CONTENT_ITEM_NAME = "REQUEST_CONTENT";

    private String getPostData(Document docContext) throws NotesException, UnsupportedEncodingException {
        String postData = null;
        if (docContext.hasItem(CONTENT_ITEM_NAME)) {
            postData = docContext.getItemValueString(CONTENT_ITEM_NAME);
        }
        else {
            int index = 0;
            String itemName = buildContentItemName(index);
            while (docContext.hasItem(itemName)) {
                m_log.DebugWrite(itemName);
                postData += docContext.getItemValueString(itemName);
                ++index;
                itemName = buildContentItemName(index);
            }
        }
        if (null != postData) {
            postData = URLDecoder.decode(postData, "UTF-8");
        }
        return postData;
    }

    private String buildContentItemName(int index) {
        String number = "000" + String.valueOf(index);
        return CONTENT_ITEM_NAME + "_" + number.substring(number.length() - 3);
    }

    private String compressOutput(String input, boolean compress) throws IOException {
        if (!compress) {
            return input;
        }
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        GZIPOutputStream gos = new GZIPOutputStream(bos);
        gos.write(input.getBytes("UTF8"));
        gos.close();
        String encoded = new String(Base64Coder.encode(bos.toByteArray()));
        if (m_fLogDebug) {
            m_log.DebugWrite("Compression: Length before=" + input.length() + ", after=" + encoded.length());
        }
        return encoded;
    }

    private void logSetup(Session s, String strType) throws NotesException {
        Database dbCur = null;
        Document docProf = null;

        m_log = null;
        if (null != s) {
            dbCur = s.getAgentContext().getCurrentDatabase();
            if (null != dbCur) {

                lotus.domino.Document docIcon = dbCur.getDocumentByID("FFFF0010");
                if (docIcon.hasItem("unpReplTestId")) {
                    docProf = dbCur.getDocumentByID(docIcon.getItemValueString("unpReplTestId"));
                    if (null == docProf) {
                        throw new TeamstudioException(ERR_INVALID_TEST_SETTING, ERR_INVALID_TEST_SETTING_MSG);
                    }
                }
                else {
                    docProf = dbCur.getProfileDocument("(Settings)", "(unpluggedconfig)");
                }
                docIcon.recycle();

                m_nLogLevel = docProf.getItemValueInteger("LogFlags_Pull");
                if (0 &lt; m_nLogLevel) {
                    m_fLogErrOnly = ((Logger.LOG_ON_ERROR_ONLY &amp; m_nLogLevel) == Logger.LOG_ON_ERROR_ONLY);
                    m_fLogDebug = ((Logger.LOG_DEBUG &amp; m_nLogLevel) == Logger.LOG_DEBUG);
                    m_log = new Logger(strType, s);
                }

                if (m_fLogDebug) {
                    if (!docProf.isProfile()) {
                        m_log.Write("WARNING! Using ALT Settings document &gt;&gt;  " + docProf.getNoteID());
                    }
                }

                if (docProf.hasItem("MaxRespSize")) {
                    int maxsizekb = docProf.getItemValueInteger("MaxRespSize");
                    if (0 &lt; maxsizekb) {
                        max_buffer = (maxsizekb * 1024);
                    }
                }

                docProf.recycle();
            }
        }
    }

    private void logCommit(Session s, Document docContext, String strMessage) {
        if (null != m_log) {
            try {
                if (null != s) {
                    if (0 &lt; m_nLogLevel) {
                        if ((!m_fLogErrOnly) || (m_fLogErrOnly &amp;&amp; (m_fHasErrors || m_fHasWarnings))) {

                            if (m_fLogDebug) {
                                m_log.DebugCommit();
                            }

                            if (null != docContext) {
                                if ((Logger.LOG_REQUEST &amp; m_nLogLevel) == Logger.LOG_REQUEST) {
                                    m_log.AddHeader("Request");
                                    m_log.LogRequestHeaders(docContext);
                                }
                            }
                            if (null != strMessage) {
                                if ((Logger.LOG_RESPONSE &amp; m_nLogLevel) == Logger.LOG_RESPONSE) {
                                    m_log.AddHeader("Response");
                                    m_log.Write(strMessage);
                                }
                            }
                            m_log.setUser(s.getEffectiveUserName());
                            m_log.setHasErrors(m_fHasErrors);
                            m_log.setHasWarnings(m_fHasWarnings);
                        }

                    }
                }

            }
            catch (Exception e) {
                e.printStackTrace();
            }
            finally {
                try {
                    if (null != m_log) {
                        m_log.dispose();
                    }
                }
                catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }

    private Map parseQueryString(Session s, String qs) throws NotesException {
        if (qs.startsWith("?")) {
            if (qs.length() == 1) {
                qs = "";
            }
            else {
                qs = qs.substring(1);
            }
        }
        Map answer = new HashMap();
        String params[] = qs.split("&amp;");

        for (int i = 0; i &lt; params.length; ++i) {
            String temp[] = params[i].split("=");
            String pval = "";
            if (temp.length &gt; 1) {
                if (temp[1].indexOf('%') == -1) {
                    pval = temp[1];
                }
                else {
                    Vector vecval = s.evaluate("@URLDecode(\"Domino\"; @ReplaceSubstring(\"" + temp[1] + "\"; \"+\"; \" \"))");
                    pval = (String)vecval.firstElement();
                }
            }
            answer.put(temp[0], pval);

        }
        return answer;
    }

    private boolean loadNoteIDs(Session s, AgentContext context, SessionInfo si) throws Exception {

        Database currentDatabase = context.getCurrentDatabase();

        Agent agent = currentDatabase.getAgent("FindModifiedIds");
        agent.runOnServer(si.getNoteId());
        si.reloadSessionDoc();
        if (m_fLogDebug) {
            m_log.DebugWrite(si.getItemValueString("AgentLog"));
        }
        Vector errors = si.getItemValue("Error");
        if (errors.size() != 0) {
            m_ab.getAgentOutput().println(errors.elementAt(0));
            throw new RuntimeException("Error '" + errors.elementAt(0) + "' calling modified IDs agent");
        }
        return true;
    }

    private boolean logErrorNote(Session s, AgentContext context, SessionInfo si, String noteId) throws Exception {
        si.replaceItemValue(ACTION_TRIGGER_FIELD, ACTION_LOG_ERR_NOTE);
        si.replaceItemValue("LogPathAPI", m_log.getLogDbApiPath());
        si.replaceItemValue("LogErrNoteNoteId", noteId);
        si.save();
        Database currentDatabase = context.getCurrentDatabase();
        Agent agent = currentDatabase.getAgent("FindModifiedIds");
        agent.runOnServer(si.getNoteId());
        si.reloadSessionDoc();
        if (m_fLogDebug) {
            m_log.DebugWrite(si.getItemValueString("AgentLog"));
            m_log.setCapturedErrorNoteID(si.getItemValueString("LoggedErrorNoteId"));
        }
        Vector errors = si.getItemValue("Error");
        if (errors.size() != 0) {
            // m_ab.getAgentOutput().println(errors.elementAt(0));
            throw new RuntimeException("Error '" + errors.elementAt(0) + "' calling modified IDs agent");
        }
        si.replaceItemValue(ACTION_TRIGGER_FIELD, "");
        si.save();
        return true;
    }

    private String convertDateTimeToDxlText(Session session, DateTime dt) throws NotesException {
        DxlExporter ex = session.createDxlExporter();
        Document docTemp = session.getAgentContext().getCurrentDatabase().createDocument();
        docTemp.replaceItemValue("dtItem", dt);
        String docXml = ex.exportDxl(docTemp);
        ex.recycle();
        docTemp.recycle();
        int start = docXml.indexOf("'dtItem'");
        start = docXml.indexOf("&lt;datetime", start);
        int end = docXml.indexOf("&lt;/item&gt;", start);
        return docXml.substring(start, end);
    }

    private String getDatabaseOpenDxl(Database db, Session session, DxlExporter ex) throws NotesException, TeamstudioException {
        DocumentCollection dc;
        DateTime dtTomorrow;
        dtTomorrow = session.createDateTime("Today");
        dtTomorrow.setNow();
        dtTomorrow.adjustDay(1);
        dc = db.getModifiedDocuments(dtTomorrow, Database.DBMOD_DOC_ICON);
        String dxlData = ex.exportDxl(dc).trim();

        String dbNs = "&lt;database xmlns='http://www.lotus.com/dxl'";
        int nDbNsEnd = dxlData.indexOf(dbNs) + dbNs.length();
        if (-1 == nDbNsEnd) {
            throw new TeamstudioException(ERR_DXLEXP_BADCLOSE, ERR_DXLEXP_BADCLOSE_MSG1);
        }
        dxlData =
                "&lt;?xml version='1.0' encoding='UTF-8' ?&gt;"
                        + "&lt;database xmlns='http://www.lotus.com/dxl' xmlns:tms='http://www.teamstudio.com/unplugged' "
                        + dxlData.substring(nDbNsEnd, (dxlData.length() - 11));

        return dxlData;

    }

    private boolean loadDesignReplSelection(Session session, Database dbRepl, SessionInfo si, DxlExporter ex) throws Exception {
        Vector designSelectElements = null;
        DateTime dtDsgnReplListUpdated = null;
        String nid = null;
        Document docReplSelect = null;

        NoteCollection nnc = dbRepl.createNoteCollection(false);
        nnc.selectAllDesignElements(true);
        nnc.setSelectionFormula("( @IsMember(\"bbreplication.xml\"; @LowerCase($Title))  |  @IsMember(\"unpsync.xml\"; @LowerCase($Title)) )");
        nnc.buildCollection();

        if (nnc.getCount() &lt; 1) {
            if (m_fLogDebug) {
                m_log.DebugWrite("No design selection list found");
            }
            return false;
        }

        nid = nnc.getFirstNoteID();
        if (nnc.getCount() &gt; 1) {
            searchSyncConfigs: while (!"".equals(nid)) {
                docReplSelect = dbRepl.getDocumentByID(nid);
                Vector vTitle = docReplSelect.getItemValue("$Title");
                Iterator iter = vTitle.iterator();
                while (iter.hasNext()) {
                    String val = (String)iter.next();
                    if (val.equalsIgnoreCase("unpsync.xml")) {
                        // it's first match to "best" so take it...
                        if (m_fLogDebug) {
                            m_log.DebugWrite("More than one Design Selection found, Using UnpSync.xml (" + nid
                                    + ") for Design Selection");
                        }
                        break searchSyncConfigs;
                    }
                }

                nid = nnc.getNextNoteID(nid);
            }
            if (null != docReplSelect) {
                if (m_fLogDebug) {
                    m_log.DebugWrite("More than one Design Selection found, Using note " + nid + " for Design Selection");
                }
            }
        }
        else {
            if (m_fLogDebug) {
                m_log.DebugWrite("Found Design Selection note: " + nid);
            }
            if (nid != "") {
                docReplSelect = dbRepl.getDocumentByID(nid);
            }
        }

        if (null == docReplSelect) {
            if (m_fLogDebug) {
                m_log.DebugWrite("Failed to load design selection list document");
            }
        }
        else {

            dtDsgnReplListUpdated = docReplSelect.getLastModified();

            String sDxl = ex.exportDxl(docReplSelect);

            DocumentBuilderFactory fac = DocumentBuilderFactory.newInstance();
            fac.setValidating(false);
            DocumentBuilder docBuilder = fac.newDocumentBuilder();
            org.w3c.dom.Document domDocNote = docBuilder.parse(new ByteArrayInputStream(sDxl.getBytes()));

            org.w3c.dom.Element rootElementNote = domDocNote.getDocumentElement();

            org.w3c.dom.NodeList elementsNote = rootElementNote.getElementsByTagName("filedata");

            String fileData = "";
            for (int j = 0; j &lt; elementsNote.getLength(); j++) {
                if (null == designSelectElements) {
                    designSelectElements = new Vector();
                }
                org.w3c.dom.Node el = elementsNote.item(j);
                fileData = el.getTextContent();

            }
            byte[] fileDataBytesDecoded;
            fileDataBytesDecoded = Base64.decode(fileData);

            si.setDesignSelectionXml(new String(fileDataBytesDecoded)); // this
                                                                        // doesn't
                                                                        // parse
                                                                        // them
                                                                        // yet

            double tdDiff = dtDsgnReplListUpdated.timeDifferenceDouble(si.getSinceJava());
            if (m_fLogDebug) {
                m_log.DebugWrite("Checking Design selection list, updated: " + dtDsgnReplListUpdated.getLocalTime()
                        + " (Last Repl: " + si.getSinceJava().getLocalTime() + ")");
                if (tdDiff &gt; 0) { // repl list newer than last repl
                    m_log.DebugWrite("Design selection list has been updated since last replication, processing all design elements");
                }
            }
            boolean isDesignReplModified = (tdDiff &gt; 0);

            si.setDesignSelectUpdated(isDesignReplModified);

            return true;

        } // ( null != docReplSelect )

        return false;
    }

    private boolean loadFieldReplSelection(Session session, Database dbRepl, SessionInfo si, DxlExporter ex) throws Exception {

        DateTime dtFieldReplListUpdated = null;
        String nid = null;
        Document docReplSelect = null;

        NoteCollection nnc = dbRepl.createNoteCollection(false);
        nnc.selectAllDesignElements(true);
        nnc.setSelectionFormula("( @IsMember(\"unpfieldsync.xml\"; @LowerCase($Title)) )");
        nnc.buildCollection();

        if (nnc.getCount() &lt; 1) {
            if (m_fLogDebug) {
                m_log.DebugWrite("No field selection list found");
            }
            return false;
        }

        nid = nnc.getFirstNoteID();
        if (nnc.getCount() &gt; 1) {
            searchSyncConfigs: while (!"".equals(nid)) {
                docReplSelect = dbRepl.getDocumentByID(nid);
                Vector vTitle = docReplSelect.getItemValue("$Title");
                Iterator iter = vTitle.iterator();
                while (iter.hasNext()) {
                    String val = (String)iter.next();
                    if (val.equalsIgnoreCase("unpsync.xml")) {
                        // it's first match to "best" so take it...
                        if (m_fLogDebug) {
                            m_log.DebugWrite("More than one Field Selection found, Using unpfieldsync.xml (" + nid
                                    + ") for Design Selection");
                        }
                        break searchSyncConfigs;
                    }
                }

                nid = nnc.getNextNoteID(nid);
            }
            if (null != docReplSelect) {
                if (m_fLogDebug) {
                    m_log.DebugWrite("More than one Field Selection found, Using note " + nid + " for Field Selection");
                }
            }
        }
        else {
            if (m_fLogDebug) {
                m_log.DebugWrite("Found Field Selection note: " + nid);
            }
            if (nid != "") {
                docReplSelect = dbRepl.getDocumentByID(nid);
            }
        }

        if (null == docReplSelect) {
            if (m_fLogDebug) {
                m_log.DebugWrite("Failed to load field selection list document");
            }
        }
        else {

            dtFieldReplListUpdated = docReplSelect.getLastModified();

            String sDxl = ex.exportDxl(docReplSelect);
            byte[] fileDataBytesDecoded = decodeFileData(sDxl);

            si.setFieldSelectionXml(new String(fileDataBytesDecoded)); // this doesn't parse them yet

            double tdDiff = dtFieldReplListUpdated.timeDifferenceDouble(si.getSinceJava());
            if (m_fLogDebug) {
                m_log.DebugWrite("Checking Field selection list, updated: " + dtFieldReplListUpdated.getLocalTime()
                        + " (Last Repl: " + si.getSinceJava().getLocalTime() + ")");
                if (tdDiff &gt; 0) { // repl list newer than last repl
                    m_log.DebugWrite("Field selection list has been updated since last replication, processing all design elements");
                }
            }
            boolean isFieldReplModified = (tdDiff &gt; 0);

            si.setFieldSelectUpdated(isFieldReplModified);

            return true;

        } // ( null != docReplSelect )

        return false;
    }

    private byte[] decodeFileData(String sDxl) throws ParserConfigurationException, SAXException, IOException,
            Base64DecodingException {
        DocumentBuilderFactory fac = DocumentBuilderFactory.newInstance();
        fac.setValidating(false);
        DocumentBuilder docBuilder = fac.newDocumentBuilder();
        org.w3c.dom.Document domDocNote = docBuilder.parse(new ByteArrayInputStream(sDxl.getBytes()));

        org.w3c.dom.Element rootElementNote = domDocNote.getDocumentElement();

        org.w3c.dom.NodeList elementsNote = rootElementNote.getElementsByTagName("filedata");
        // Vector designSelectElements = null;
        String fileData = "";
        for (int j = 0; j &lt; elementsNote.getLength(); j++) {
            org.w3c.dom.Node el = elementsNote.item(j);
            fileData += el.getTextContent();
        }

        return Base64.decode(fileData);
    }

    public static String xmlEscape(String in) {
        StringBuffer out = new StringBuffer(in.length());
        char[] chars = in.toCharArray();
        for (int i = 0; i &lt; chars.length; ++i) {
            // if (chars[i] &lt; 32) {
            // method is the same as replicator.java except that we omit control chars &lt; 32...

            // out.append("&lt;nonxmlchar value=\"");
            // String hex = "0000" + Integer.toHexString(chars[i]);
            // out.append(hex.substring(hex.length() - 4));
            // out.append("\"/&gt;");

            // } else if (chars[i] &lt; 128) {
            switch (chars[i]) {
            case '\"':
                out.append("&amp;quot;");
                break;
            case '\'':
                out.append("&amp;apos;");
                break;
            case '&lt;':
                out.append("&amp;lt;");
                break;
            case '&gt;':
                out.append("&amp;gt;");
                break;
            case '&amp;':
                out.append("&amp;amp;");
                break;
            default:
                out.append(chars[i]);
            }
            // continue;
            // }else {
            // out.append("&amp;#x");
            // String hex = "0000" + Integer.toHexString(chars[i]);
            // out.append(hex.substring(hex.length() - 4));
            // out.append(";");
            // }
        }
        return out.toString();
    }

    private static final int ERR_NO_DEVICE = 9996;
    private static final String ERR_NO_DEVICE_MSG = "No device in request!";
    private static final int ERR_DB_NOT_OPEN = 9995;
    private static final int ERR_DB_NOT_OPEN2 = 9994;
    private static final String ERR_DB_NOT_OPEN_MSG = "Target database not opened. Verify path and access.";
    private static final int ERR_DXLEXP_BADCLOSE = 9997;
    private static final String ERR_DXLEXP_BADCLOSE_MSG = "Data DXL export did not contain expected closing element.";
    private static final int ERR_DXLEXP_BADOPEN = 9998;
    private static final String ERR_DXLEXP_BADOPEN_MSG = "Design DXL export did not contain expected starting element.";
    private static final String ERR_INVALID_TEST_SETTING_MSG = "Invalid test settings profile!";
    private static final int ERR_INVALID_TEST_SETTING = 9993;
    private static final String ERR_DXLEXP_BADCLOSE_MSG1 = "No valid db open dxl found!";
    private static final String ERR_NO_PULL_TIME_MSG = "No valid pull time found in session document.";
    private static final int ERR_NO_PULL_TIME = 9992;
    private static final String ERR_CANT_CREATE_SESS_MSG = "Could not create synchronization session!";
    private static final int ERR_CANT_CREATE_SESS = 9991;

    private Map params;
    private String targetDbPath;
    private String targetDbApiPath;

}</java><java name='com/teamstudio/unplugged/libs/SessionInfo.java'>package com.teamstudio.unplugged.libs;

import java.io.ByteArrayInputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Vector;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import lotus.domino.AgentContext;
import lotus.domino.Database;
import lotus.domino.DateTime;
import lotus.domino.Document;
import lotus.domino.Item;
import lotus.domino.NotesException;
import lotus.domino.RichTextItem;
import lotus.domino.Session;
import lotus.domino.View;
import lotus.domino.ViewEntry;

import org.w3c.dom.Element;

public final class SessionInfo {

    private static final String ERR_MISSING_SESSTAG_EL_MSG = "Missing element in session tag, must be in format NxTxOx";
    private static final int ERR_MISSING_SESSTAG_EL = 9799;
    private static final String ERR_USER_NOT_HAVE_DB_MSG = "Database not defined for user!";
    private static final int ERR_USER_NOT_HAVE_DB = 9798;
    private static final String ERR_USER_NOT_DEFINED_MSG = "User not defined!";
    private static final int ERR_USER_NOT_DEFINED = 9797;
    private static final String ERR_SESSION_IDS_BAD_OFFSET_MSG =
            "Bad value found in sessions pending IDs: offset does not match delimiter";
    private static final int ERR_SESSION_IDS_BAD_OFFSET = 9796;

    private static final String ERR_SESSION_NOT_LOADED_MSG = "Session document not loaded; call loadSession first.";
    private static final int ERR_SESSION_NOT_LOADED = 9795;
    private static SessionInfo si;
    public static final int TYPE_NOTE = 1;
    public static final int TYPE_DELETION = 2;

    private SessionInfo() {
    }

    private String noteId;
    private int cntProcessed;
    private int offset;
    private Document docSess;
    private boolean isNew;
    private boolean isLoaded;
    private String sPendingIds;
    private int lastOffset;
    private String selectFormula;
    private boolean hasSelect;
    private Map designSelectElements;
    private boolean designSelectUpdated;
    private boolean hasDesignSelect;
    private boolean supportsChunking;
    private int cnt;
    private int cntDeleted;
    private boolean isSessionDeleted;
    private String openingDxlDbTag;
    private String designSelXml;
    private ArrayList attachmentFilters;
    private boolean sendDocAttachments;
    private HashSet deviceUnids = null;
    private String deviceUnidsDelimited = null;
    private boolean skipPurges;
    private DateTime sinceJava;
    private DateTime sinceNotes;
    private boolean firstPull;
    private boolean forceUpgrade;
    private int cntUpgradeSkippedDesign;
    private int cntUpgradeSkippedData;
    private String targetDbApiPath = null;
    private String fieldSelXml;
    private boolean fieldSelectUpdated;
    private ArrayList fieldSelectElements;
    private boolean hasFieldSelect;

    public String getTargetDbApiPath() {
        return targetDbApiPath;
    }

    private void reset() {
        noteId = null;
        cntProcessed = 0;
        offset = 0;
        docSess = null;
        isNew = false;
        isLoaded = false;
        sPendingIds = null;
        lastOffset = 0;
        selectFormula = null;
        hasSelect = false;
        designSelectElements = null;
        designSelectUpdated = false;
        hasDesignSelect = false;
        supportsChunking = false;
        cnt = 0;
        cntDeleted = 0;
        isSessionDeleted = false;
        openingDxlDbTag = null;
        attachmentFilters = null;
        sendDocAttachments = false;
        firstPull = false;
        forceUpgrade = false;
        sinceNotes = null;
        sinceJava = null;
        skipPurges = false;
        cntUpgradeSkippedData = 0;
        cntUpgradeSkippedDesign = 0;
        targetDbApiPath = null;
        fieldSelXml = null;
        fieldSelectUpdated = false;
        fieldSelectElements = null;
        hasFieldSelect = false;
    }

    public Database getReplicator() throws NotesException {
        return docSess.getParentDatabase();
    }

    public ArrayList getAttachmentFilters() {
        return attachmentFilters;
    }

    public boolean hasAttachmentFilters() {
        return sendDocAttachments;
    }

    public int getCount() {
        return cnt;
    }

    public String getOpeningDxlDbTag() {
        return openingDxlDbTag;
    }

    public void setOpeningDxlDbTag(String openingDxlDbTag) {
        this.openingDxlDbTag = openingDxlDbTag;
    }

    public int getCountProcessed() {
        return cntProcessed;
    }

    public int getCountDeleted() {
        return cntDeleted;
    }

    public String getSelectFormula() {
        return selectFormula;
    }

    public void setSelectFormula(String selectFormula) {
        this.selectFormula = selectFormula;
    }

    public boolean hasSelect() {
        return hasSelect;
    }

    public void setHasSelect(boolean hasSelect) {
        this.hasSelect = hasSelect;
    }

    public boolean hasDesignSelect() {
        return hasDesignSelect;
    }

    public void setHasDesignSelect(boolean hasDesignSelect) {
        this.hasDesignSelect = hasDesignSelect;
    }

    public boolean isDesignSelectUpdated() {
        return designSelectUpdated;
    }

    public void setDesignSelectUpdated(boolean designSelectUpdated) {
        this.designSelectUpdated = designSelectUpdated;
    }

    public Map getDesignSelectElements() {
        return designSelectElements;
    }

    public ArrayList getFieldSelectElements() {
        return fieldSelectElements;
    }

    public int getCntUpgradeSkippedDesign() {
        return cntUpgradeSkippedDesign;
    }

    public void upgradeDesignNoteSkipped() {
        ++cntUpgradeSkippedDesign;
    }

    public int getCntUpgradeSkippedData() {
        return cntUpgradeSkippedData;
    }

    public void upgradeDataNoteSkipped() {
        ++cntUpgradeSkippedData;
    }

    public IReplicationNote getNextReplicationNote() throws NotesException {
        String sID = getNextId(TYPE_NOTE);
        if (null == sID) {
            return null;
        }
        return PVObjectFactory.getInstance().createReplicationNote(sID, this);
    }

    public String getNextId(int Type) throws NotesException {
        if (null == sPendingIds) {
            RichTextItem itm = (RichTextItem)docSess.getFirstItem("IDs");
            if (null != itm) {
                sPendingIds = itm.getUnformattedText();
            }
            else {
                return null;
            }
        }

        int start = offset;
        lastOffset = offset;
        int end;

        if (start &lt; sPendingIds.length()) {
            if (',' == sPendingIds.charAt(start)) {
                start++;
            }
            else {
                throw new TeamstudioException(ERR_SESSION_IDS_BAD_OFFSET, ERR_SESSION_IDS_BAD_OFFSET_MSG);
            }
            end = sPendingIds.indexOf(",", (start));
            String sId = null;
            if (-1 == end) {
                end = sPendingIds.length();
                offset = end;
                cntProcessed++;
                sId = sPendingIds.substring(start);
            }
            else {
                offset = end;
                cntProcessed++;
                sId = sPendingIds.substring(start, end);
            }

            if ((-1 &lt; sId.indexOf("\n")) || (-1 &lt; sId.indexOf("\r"))) {
                return sId.replace("\r", "").replace("\n", ""); // rti must add these
            }
            else {
                return sId;
            }
        }
        return null;

    }

    public boolean isLoaded() {
        return isLoaded;
    }

    public int getOffset() {
        return offset;
    }

    public void setOffset(int offset) {
        this.offset = offset;
    }

    public boolean isNew() {
        return isNew;
    }

    public static SessionInfo getInstance() {
        if (si == null) {
            si = new SessionInfo();
        }
        return si;
    }

    void loadDbConfig(Session session, Database dbReplicator, String server, String dbPath, String srcID) throws NotesException {
        ViewEntry entry = null;
        View vwLookup = null;

        if ((null != srcID) &amp;&amp; (!"".equals(srcID))) {
            vwLookup = dbReplicator.getView("DatabaseSrcIdLU");
            String srcIdTemp = "00000000" + srcID;
            String srcIdPadded = srcIdTemp.substring(srcIdTemp.length() - 8);
            vwLookup.refresh();
            entry = vwLookup.getEntryByKey(srcIdPadded, true);
            if (null == entry) {
                Pull.writeDebug("Database config not found; source id: " + srcIdPadded);
            }
            else {
                Pull.writeDebug("Database config found by source id: " + srcIdPadded);
            }
        }

        if (null == entry) { // no srcID (old client) or no longer valid so go the long way
            Pull.writeDebug("Searching for database config by profile/user name.");
            View vwUsers = dbReplicator.getView("Users");

            String userNameAbbrev = session.createName(session.getEffectiveUserName()).getAbbreviated();

            entry = vwUsers.getEntryByKey(userNameAbbrev, true);
            if (null == entry) {
                throw new TeamstudioException(ERR_USER_NOT_DEFINED, ERR_USER_NOT_DEFINED_MSG);
            }

            ArrayList profiles = getArrayListFromColumnValue(entry.getColumnValues().elementAt(2));
            if (null == profiles) {
                profiles = new ArrayList();
            }
            profiles.add(userNameAbbrev);
            vwLookup = dbReplicator.getView("UserDatabases");

            Vector key = new Vector();

            key.add(" ");
            key.add(server);
            key.add(dbPath);

            entry = null;
            vwUsers.recycle();

            Iterator iter = profiles.iterator();
            while (iter.hasNext() &amp;&amp; (null == entry)) { // exit loop on first we find

                key.set(0, iter.next());
                entry = vwLookup.getEntryByKey(key, true);

            }
        }

        String selectFormula = "";
        if (null == entry) {
            throw new TeamstudioException(ERR_USER_NOT_HAVE_DB, ERR_USER_NOT_HAVE_DB_MSG);
        }

        Vector colVals = entry.getColumnValues();
        selectFormula = (String)colVals.elementAt(3);
        attachmentFilters = getArrayListFromColumnValue(colVals.elementAt(6));
        sendDocAttachments = (null != attachmentFilters);
        Pull.writeDebug("Loaded database config from " + entry.getNoteID());
        vwLookup.recycle();

        boolean hasDataReplFormula = (0 != selectFormula.length()) ? true : false;
        setHasSelect(hasDataReplFormula);
        setSelectFormula(selectFormula);

    }

    ArrayList getArrayListFromColumnValue(Object o) {
        if (o instanceof java.util.Vector) {
            return new ArrayList((Vector)o);
        }
        else if (o instanceof java.lang.String) {
            if (!((String)o).equals("")) {
                ArrayList al = new ArrayList();
                al.add((o));
                return al;
            }
        }
        return null;
    }

    public boolean loadSession(Session s, AgentContext context, String apiPath, Map params, boolean forceUpgrade) throws Exception {
        return si.getSessionDoc(s, context, apiPath, params, true, forceUpgrade);
    }

    public boolean reloadSessionDoc() throws Exception {
        if (null != docSess) {
            Database currentDatabase = docSess.getParentDatabase();
            docSess.recycle();
            docSess = currentDatabase.getDocumentByID(noteId);
            if (null != docSess) {
                restoreSession();
                return true;
            }
        }

        return false;
    }

    public String getSessionInfoTag() {
        return ("N" + noteId + "T" + cntProcessed + "O" + offset);
    }

    private boolean parseSessionInfoTag(String sInfoTag) {
        if ("NTO".equalsIgnoreCase(sInfoTag)) {
            // NTO is starting chunk, to indicate client takes chunks
            reset(); // initialize or reset variables (e.g. if called again because deleted/expired sess doc found)
            return true;
        }

        try { // from here on we throw an error if we can't parse. Device shouldn't ever return anything but what we sent it.
            int posN = sInfoTag.indexOf("N");
            int posT = sInfoTag.indexOf("T");
            int posO = sInfoTag.indexOf("O");
            if ((posN == -1) || (posT == -1) || (posO == -1)) {
                throw new TeamstudioException(ERR_MISSING_SESSTAG_EL, ERR_MISSING_SESSTAG_EL_MSG);
            }
            noteId = sInfoTag.substring(posN + 1, posT);
            cntProcessed = Integer.parseInt(sInfoTag.substring(posT + 1, posO));
            offset = Integer.parseInt(sInfoTag.substring(posO + 1));
            return true;

        }
        catch (Exception ex) {
            throw new TeamstudioException("Could not parse session tag, error: ", ex);
        }

    }

    public void markForDeletion() throws NotesException {
        isSessionDeleted = true;
        docSess.removeItem("IDs");
        docSess.replaceItemValue("MarkedForDeletion", "1");
        save(); // update the other fields and save docSess
    }

    private boolean getSessionDoc(Session s, AgentContext context, String apiPath, Map params, boolean create, boolean upgrade)
            throws Exception {
        Database currentDatabase = context.getCurrentDatabase();
        String sSI = (String)params.get("si");

        if ((null != sSI) &amp; (!"".equals(sSI))) {
            parseSessionInfoTag(sSI); // do this first because it resets all members if sSi = "NTO"
            supportsChunking = true;
        }

        if (null != noteId) {
            docSess = currentDatabase.getDocumentByID(noteId);

            if (null != docSess) {

                restoreSession();
                // TODO do we want to check age of session here and discard if old?
                // Currently the client doesn't save session info after failure / lost service
                // so there's no use-case right now but if we ever restart a session after regain service
                // we might need to check how old the session is and load a new one if appropriate.
                if (isSessionDeleted) {
                    return false;
                }
                return true;

            }
        }
        else if (create) {

            docSess = currentDatabase.createDocument();
            docSess.replaceItemValue("Form", "TempDoc");
            docSess.replaceItemValue("Path", apiPath); // pass the path we created per any base dir specified on URL
            docSess.replaceItemValue("pin", params.get("device"));
            docSess.replaceItemValue("JavaTime", params.get("sinceJava"));
            docSess.replaceItemValue("NotesTime", params.get("sinceNotes"));

            targetDbApiPath = apiPath;

            if (upgrade) {
                forceUpgrade = true;
                docSess.replaceItemValue("ForceUpgrade", "1");
            }

            String sinceTime = (String)params.get("sinceJava");
            sinceJava = s.createDateTime(new Date(Long.valueOf(sinceTime).longValue()));
            if (sinceTime.equals("0")) {
                skipPurges = true;
                firstPull = true;
                docSess.replaceItemValue("SkipPurges", "1");
                docSess.replaceItemValue("FirstPull", "1");
            }

            docSess.replaceItemValue("UpgradeSkippedData", Double.valueOf(0));
            docSess.replaceItemValue("UpgradeSkippedDesign", Double.valueOf(0));

            docSess.replaceItemValue("UserName", s.getEffectiveUserName());
            Item authorsItem = docSess.replaceItemValue("TempAuthor", s.getEffectiveUserName());
            authorsItem.setSummary(true);
            authorsItem.setAuthors(true);
            docSess.save(true, true);
            noteId = docSess.getNoteID();
            cntProcessed = 0;
            isNew = true;
            isLoaded = true;
            return true;
        }
        return false;
    }

    public boolean isFirstPull() {
        return firstPull;
    }

    private void restoreSession() throws Exception {
        // restore things that should persist across chunks

        if (docSess.hasItem("TD_NotesTime")) {
            sinceNotes = (DateTime)docSess.getItemValueDateTimeArray("TD_NotesTime").get(0);
            Pull.writeDebug("Since time restored from session document: " + sinceNotes.toJavaDate());
        }

        targetDbApiPath = docSess.getItemValueString("Path"); // we don't currently save path on session save since we use one doc
                                                              // per db...

        selectFormula = docSess.getItemValueString("selectFormula");
        hasSelect = ("1".equals(docSess.getItemValueString("hasSelect"))) ? true : false;

        designSelectUpdated = ("1".equals(docSess.getItemValueString("designSelectUpdated"))) ? true : false;
        hasDesignSelect = ("1".equals(docSess.getItemValueString("hasDesignSelect"))) ? true : false;

        isSessionDeleted = ("1".equals(docSess.getItemValueString("isSessionDeleted"))) ? true : false;

        forceUpgrade = ("1".equals(docSess.getItemValueString("ForceUpgrade"))) ? true : false;
        skipPurges = ("1".equals(docSess.getItemValueString("SkipPurges"))) ? true : false;
        firstPull = ("1".equals(docSess.getItemValueString("FirstPull"))) ? true : false;

        Pull.writeDebug("Restored session information: Upgrade: " + forceUpgrade + "; send purges? " + !skipPurges
                + "; first pull? " + firstPull);

        cnt = (int)docSess.getItemValueDouble("Count");
        cntDeleted = (int)docSess.getItemValueDouble("CountDeleted");
        cntUpgradeSkippedDesign = (int)docSess.getItemValueDouble("UpgradeSkippedDesign");
        cntUpgradeSkippedData = (int)docSess.getItemValueDouble("UpgradeSkippedData");

        if (forceUpgrade) {
            Pull.writeDebug("Current upgrade skip counts: Data: " + cntUpgradeSkippedData + "; Design: " + cntUpgradeSkippedDesign);
        }

        openingDxlDbTag = docSess.getItemValueString("OpeningDxlDbTag");

        sendDocAttachments = ("1".equals(docSess.getItemValueString("sendDocAttachments"))) ? true : false;
        if (sendDocAttachments) {
            if (docSess.hasItem("attachmentFilter")) {
                attachmentFilters = new ArrayList(docSess.getItemValue("attachmentFilter"));
            }
        }

        deviceUnidsDelimited = docSess.getItemValueString("deviceUnids");
        if (null != deviceUnidsDelimited &amp;&amp; deviceUnidsDelimited.length() &gt; 0) {
            deviceUnids = parseDeviceUnids(deviceUnidsDelimited);
        }
        // last because call updates hasdesignselect:
        designSelXml = docSess.getItemValueString("designSelectXml");
        loadDesignSelection();

        fieldSelXml = docSess.getItemValueString("fieldSelXml");
        loadFieldSelection();

        isLoaded = true;

    }

    public boolean SupportsChunking() {
        return supportsChunking;
    }

    public String getNoteId() {
        return noteId;
    }

    public Vector getItemValue(String name) throws NotesException {
        if (null == docSess) {
            throw new TeamstudioException(ERR_SESSION_NOT_LOADED, ERR_SESSION_NOT_LOADED_MSG);
        }
        return docSess.getItemValue(name);
    }

    public String getItemValueString(String name) throws NotesException {
        if (null == docSess) {
            throw new TeamstudioException(ERR_SESSION_NOT_LOADED, ERR_SESSION_NOT_LOADED_MSG);
        }
        return docSess.getItemValueString(name);
    }

    public Item replaceItemValue(String name, Object obj) throws NotesException {
        if (null == docSess) {
            throw new TeamstudioException(ERR_SESSION_NOT_LOADED, ERR_SESSION_NOT_LOADED_MSG);
        }
        return docSess.replaceItemValue(name, obj);
    }

    public boolean save() throws NotesException {
        if (null == docSess) {
            throw new TeamstudioException(ERR_SESSION_NOT_LOADED, ERR_SESSION_NOT_LOADED_MSG);
        }

        // targetDbApiPath / "Path" //we don't currently save path on session save since we use one doc per db...

        // save things that should persist across chunks
        docSess.replaceItemValue("selectFormula", selectFormula);
        docSess.replaceItemValue("hasSelect", ((hasSelect) ? "1" : "0"));

        docSess.replaceItemValue("designSelectUpdated", ((designSelectUpdated) ? "1" : "0"));
        docSess.replaceItemValue("hasDesignSelect", ((hasDesignSelect) ? "1" : "0"));
        docSess.replaceItemValue("openingDxlDbTag", openingDxlDbTag);
        docSess.replaceItemValue("isSessionDeleted", ((isSessionDeleted) ? "1" : "0"));

        docSess.replaceItemValue("UpgradeSkippedData", Double.valueOf(cntUpgradeSkippedData));
        docSess.replaceItemValue("UpgradeSkippedDesign", Double.valueOf(cntUpgradeSkippedDesign));

        docSess.replaceItemValue("sendDocAttachments", ((sendDocAttachments) ? "1" : "0"));
        if (sendDocAttachments) {
            if (null != attachmentFilters) {
                docSess.replaceItemValue("attachmentFilter", new Vector(attachmentFilters));
            }
        }

        if (null != deviceUnidsDelimited &amp;&amp; deviceUnidsDelimited.length() &gt; 0) {
            docSess.replaceItemValue("deviceUnids", deviceUnidsDelimited);
        }

        docSess.replaceItemValue("designSelectXml", designSelXml);
        docSess.replaceItemValue("fieldSelXml", fieldSelXml);

        return docSess.save(true, true);
    }

    public DateTime getUntilTime() throws NotesException {
        if (docSess.hasItem("UntilTime")) {
            return (DateTime)docSess.getItemValueDateTimeArray("UntilTime").firstElement();
        }
        return null;
    }

    public void resetToLastOffset() {
        cntProcessed--;
        offset = lastOffset;
    }

    public void setDesignSelectionXml(String designSelectionXML) throws Exception {
        designSelXml = designSelectionXML;
    }

    public void loadDesignSelection() throws Exception {
        designSelectElements = null;
        if (null == designSelXml || "".equals(designSelXml)) {
            return;
        }

        try {
            DocumentBuilderFactory fac = DocumentBuilderFactory.newInstance();
            fac.setValidating(false);
            DocumentBuilder docBuilder = fac.newDocumentBuilder();
            org.w3c.dom.Document domDocFile = docBuilder.parse(new ByteArrayInputStream(designSelXml.getBytes()));

            Element rootElement = domDocFile.getDocumentElement();

            org.w3c.dom.NodeList elements = rootElement.getElementsByTagName("select");
            for (int j = 0; j &lt; elements.getLength(); j++) {
                if (null == designSelectElements) {
                    designSelectElements = new HashMap();
                }
                Element el = (Element)elements.item(j);

                String name = null;
                if (el.hasAttribute("name")) {
                    name = el.getAttribute("name");
                }
                else {
                    Element elName = (Element)el.getElementsByTagName("name").item(0);
                    if (null != elName) {
                        name = elName.getTextContent();
                    }
                }

                String formula = null;
                if (el.hasAttribute("formula")) {
                    formula = el.getAttribute("formula");
                }
                else {
                    Element elFormula = (Element)el.getElementsByTagName("formula").item(0);
                    if (null != elFormula) {
                        formula = elFormula.getTextContent();
                    }
                }

                DesignSelect ds =
                        new DesignSelect((el.hasAttribute("notetype")) ? el.getAttribute("notetype") : "all", name, formula);
                if (!designSelectElements.containsKey(ds.getType())) {
                    designSelectElements.put(ds.getType(), new ArrayList());
                }
                ((ArrayList)designSelectElements.get(ds.getType())).add(ds);
            }

            hasDesignSelect = (null != designSelectElements);

        }
        catch (Exception ex) {
            throw new TeamstudioException("Could not parse Design Formula, error: ", ex);
        }

    }

    private HashSet parseDeviceUnids(String delimitedUnids) {
        if (null == delimitedUnids || "".equals(delimitedUnids)) {
            return null;
        }
        String[] unids = delimitedUnids.split(";");
        return new HashSet(Arrays.asList(unids));
    }

    public void loadDeviceUnids(String deviceUnidsString) {
        deviceUnidsDelimited = deviceUnidsString;
        if (null != deviceUnidsDelimited &amp;&amp; deviceUnidsDelimited.length() &gt; 0) {
            deviceUnids = parseDeviceUnids(deviceUnidsDelimited);
        }
    }

    public HashSet getDeviceUnidMap() {
        return deviceUnids;
    }

    public boolean isSkipPurges() {
        return skipPurges;
    }

    public DateTime getSinceJava() {
        return sinceJava;
    }

    public DateTime getSinceNotes() {
        return sinceNotes;
    }

    public boolean isForceUpgrade() {
        return forceUpgrade;
    }

    public void setFieldSelectionXml(String fieldSelectionXML) {
        if (null != fieldSelectionXML || (!"".equals(fieldSelectionXML))) {
            hasFieldSelect = true;
        }
        fieldSelXml = fieldSelectionXML;
    }

    public boolean isFieldSelectUpdated() {
        return fieldSelectUpdated;
    }

    public void setFieldSelectUpdated(boolean fieldSelectUpdated) {
        this.fieldSelectUpdated = fieldSelectUpdated;
    }

    public void loadFieldSelection() throws Exception {
        fieldSelectElements = null;
        if (null == fieldSelXml || "".equals(fieldSelXml)) {
            return;
        }
        fieldSelectElements = new ArrayList();
        try {
            DocumentBuilderFactory fac = DocumentBuilderFactory.newInstance();
            fac.setValidating(false);
            DocumentBuilder docBuilder = fac.newDocumentBuilder();
            org.w3c.dom.Document domDocFile = docBuilder.parse(new ByteArrayInputStream(fieldSelXml.getBytes()));

            Element rootElement = domDocFile.getDocumentElement();

            org.w3c.dom.NodeList forms = rootElement.getElementsByTagName("form");
            for (int j = 0; j &lt; forms.getLength(); j++) {
                Element form = (Element)forms.item(j);

                String name = null;
                if (form.hasAttribute("name")) {
                    name = form.getAttribute("name");
                }
                else {
                    Element elName = (Element)form.getElementsByTagName("name").item(0);
                    if (null != elName) {
                        name = elName.getTextContent();
                    }
                }

                String formula = null;
                if (form.hasAttribute("formula")) {
                    formula = form.getAttribute("formula");
                }
                else {
                    Element elFormula = (Element)form.getElementsByTagName("formula").item(0);
                    if (null != elFormula) {
                        formula = elFormula.getTextContent();
                    }
                }

                FieldSelect fs =
                        new FieldSelect((form.hasAttribute("type") ? form.getAttribute("type") : "include"), name, formula); // TODO
                                                                                                                             // wc?

                org.w3c.dom.NodeList fields = form.getElementsByTagName("field");
                for (int k = 0; k &lt; fields.getLength(); k++) {

                    Element field = (Element)fields.item(k);

                    name = null;
                    if (field.hasAttribute("name")) {
                        name = field.getAttribute("name");
                    }
                    else {
                        Element elName = (Element)field.getElementsByTagName("name").item(0);
                        if (null != elName) {
                            name = elName.getTextContent();
                        }
                    }

                    formula = null;
                    if (field.hasAttribute("formula")) {
                        formula = field.getAttribute("formula");
                    }
                    else {
                        Element elFormula = (Element)field.getElementsByTagName("formula").item(0);
                        if (null != elFormula) {
                            formula = elFormula.getTextContent();
                        }
                    }
                    if (null != formula) {
                        Pull.writeDebug("Formula matches are not supported on field selections, name: " + name + "; formula: "
                                + formula + "; parent: " + fs.getName());
                        formula = null;
                    }

                    fs.addChild(new FieldSelect(
                            (field.hasAttribute("type") ? field.getAttribute("type").toLowerCase() : "include"), name, formula));
                }

                // ADD TO MASTER LIST
                fieldSelectElements.add(fs);
            }

            hasFieldSelect = (null != fieldSelectElements);

        }
        catch (Exception ex) {
            throw new TeamstudioException("Could not parse Field Selection, error: ", ex);
        }

    }

    public boolean hasFieldSelect() {
        return hasFieldSelect;
    }

    public void forceFieldUpgrade() throws NotesException {
        docSess.replaceItemValue("ForceFieldUpdate", "1");
    }

}
</java><java name='com/teamstudio/unplugged/libs/TeamstudioException.java'>package com.teamstudio.unplugged.libs;

public class TeamstudioException extends RuntimeException {
	private static final long serialVersionUID = 1L;
	private int m_code = 0;
	
	public TeamstudioException(int errorCode, String message) {
		super(message);
		m_code = errorCode;
	}
	
	public TeamstudioException(String message, Throwable cause) {
		super(message);
		this.cause = cause;
	}
	
	public String getMessage() { 
		if (null != cause) {
			return super.getMessage() + ": " + m_code + ": " + cause.getMessage();
		}
		return m_code + ": " + super.getMessage();
	}
	
	public int getErrorCode() {
		return m_code;
	}
	
	public void printStackTrace() {
		super.printStackTrace();
		if (null != cause) {
			System.err.println("Caused by: ");
			cause.printStackTrace();
		}
	}
	
	private Throwable cause;
}
</java><java name='com/teamstudio/unplugged/libs/WildcardPattern.java'>package com.teamstudio.unplugged.libs;

public class WildcardPattern {

	private String[] tokens;
	private boolean mustStartWithFirst;
	private boolean mustEndWithLast;

	
	
	public WildcardPattern(String pattern) {
		super();
		loadPattern(pattern);
	}

	public boolean loadPattern(String pattern){
		tokens = null;
		if(null==pattern || "".equals(pattern)){
			return false;
		}
		if(-1 == pattern.indexOf("\\*")){
			tokens = pattern.toUpperCase().split("\\*");
		} else {
			//split on  *  but not  \*
			//pattern:  (?&lt;!\\\\)  = negative look-behind for  \  (escaped, for java and regex)
			//but  (\\*)  otherwise matches  *  escaped
			tokens = pattern.toUpperCase().split("(?&lt;!\\\\)(\\*)"); 
			for(int i = 0; i&lt;tokens.length; i++){
				String tok = tokens[i];
				int pos = tok.indexOf("\\*");
				if(-1!=pos){
					tokens[i] = (tok.substring(0, pos) + "*" +  tok.substring(pos+2));
				}
			}
		}	
		
		mustStartWithFirst = ( '*' != pattern.charAt(0) );
		mustEndWithLast = ( '*' != pattern.charAt(pattern.length()-1) );
		return true;
	}

	public boolean matches(String source){
		
		if(null==tokens){return false;}
		
		int idxToken = 0;
		int posIn= 0;
		boolean match = true;
		String src = source.toUpperCase();

		if((1==tokens.length) &amp;&amp; mustStartWithFirst &amp;&amp; mustEndWithLast){ //no wild cards
			return src.equals(tokens[0]);
		}
		
		if( mustStartWithFirst ){
			//need first string to match beginning
			if( !src.startsWith(tokens[0])){
				match = false;
				return false;
			}else{
				++idxToken;  // don't check it again
			}
		}

		int idxLastTokenToCheck = tokens.length - 1;
		if(match &amp;&amp; mustEndWithLast){
			//need last token to match end of string
			if( !src.endsWith(tokens[tokens.length-1])){
				match = false;
				return false;
			}else{
				--idxLastTokenToCheck; // don't check it again
			}
		}

		while ( match &amp;&amp; (idxToken &lt;= idxLastTokenToCheck) ){
			posIn = src.indexOf(tokens[idxToken], posIn);
			if(-1 == posIn){
				match=false;
			}else{
				posIn = posIn +  tokens[idxToken].length();
				++idxToken;
			}
		}



		return match;
	}

}
</java><java name='com/teamstudio/unplugged/libs/pv1/ReplicationNote.java'>package com.teamstudio.unplugged.libs.pv1;

import java.io.StringReader;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Vector;

import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import lotus.domino.Database;
import lotus.domino.Document;
import lotus.domino.DxlExporter;
import lotus.domino.EmbeddedObject;
import lotus.domino.Item;
import lotus.domino.NotesException;
import lotus.domino.Session;

import com.teamstudio.unplugged.libs.DesignSelect;
import com.teamstudio.unplugged.libs.IReplicationNote;
import com.teamstudio.unplugged.libs.Logger;
import com.teamstudio.unplugged.libs.SessionInfo;
import com.teamstudio.unplugged.libs.TeamstudioException;
import com.teamstudio.unplugged.libs.WildcardPattern;

public class ReplicationNote implements IReplicationNote {
    private static final String ERRMSG_DXLEXPORTERRLOGMSG =
            "** DXL Export Error: DXLExporter.exportDxl() returned the following error: ";
    private static final String ERRMSG_DXLEXPORTFAILEDCHECKLOG =
            "DXL Exporter error. Check the Unplugged server log Debugging Messages for details.";
    private static final String ERR_ATTACH_FILTER_FAIL_MSG = "Attempt to filter attachments failed!";
    private static final int ERR_ATTACH_FILTER_FAIL = 9899;
    private static final String ATTACH_FILTER_SEND_ALL = "*.*";
    private static Templates cachedXSLT;
    private static Templates cachedDocumentXSLT;
    private int type;
    private String id;
    private Document doc;
    private String noteDescription = "Not set";
    private boolean wantType;
    private boolean matchesFormula;
    private boolean forceNoteFormat;
    private SessionInfo si;
    private boolean hasError = false;
    private String designNoteType;
    private String designMatchInfo;

    public boolean hasError() {
        return hasError;
    }

    public String getTypeName() {
        String stype = "Unknown";
        switch (type) {
        case TYPE_DATA:
            stype = "DATA";
            break;
        case TYPE_DESIGN:
            stype = "DSGN";
            break;
        case TYPE_DELETION:
            stype = "DEL";
            break;
        }
        return stype;
    }

    public String toString() {
        return getTypeName() + ": " + id + "; Matches: " + matchesFormula
                + ((null != designMatchInfo) ? (" (" + designMatchInfo + ")") : "") + ";  " + noteDescription;
    }

    public static int getTypeFromFirstChar(String ID) {
        int retval = TYPE_UNKNOWN;
        char first = ID.charAt(0);
        switch (first) {
        case 'z':
            retval = TYPE_DESIGN;
            break;
        case 'x':
            retval = TYPE_DELETION;
            break;
        case 'y':
            retval = TYPE_DATA;
            break;

        case 'u':
            retval = TYPE_UNKNOWN;
            break;
        }
        return retval;
    }

    public ReplicationNote(String IDWithTypePrefix, SessionInfo SI) {
        super();
        if ((null == IDWithTypePrefix) || (1 &gt; IDWithTypePrefix.length())) {
            return;
        }
        type = getTypeFromFirstChar(IDWithTypePrefix);
        id = IDWithTypePrefix.substring(1);
        si = SI;
    }

    public boolean matchesSelectFormula(Session session, String sFmla) {
        Object doesMatch;
        try {
            doesMatch = session.evaluate(sFmla, doc).elementAt(0);
            if (doesMatch instanceof Double &amp;&amp; ((Double)doesMatch).doubleValue() != 0) {
                return true;
            }
            return false;

        }
        catch (NotesException e) {
            noteDescription += " FORMULA EVAL FAILED!";
            return false;
        }
    }

    public boolean loadDoc(Session session, Database db) throws NotesException {
        if (TYPE_DELETION == type) {
            noteDescription = "Deletion Stub";
            wantType = true;
            matchesFormula = true;
            return true;
        }
        else {
            try {
                doc = db.getDocumentByID(id);
            }
            catch (NotesException ex) {
                ex.printStackTrace();
                noteDescription = "Error loading note: " + ex.id + ":" + ex.text;
                hasError = true;
            }
            if (null == doc) {
                if (!hasError) { // don't overwrite if error included...
                    noteDescription = "Not loaded; Reader field protected or no longer available.";
                }
                return false;
            }
            else {
                if (TYPE_UNKNOWN == type) { // if the type was unknown when created, find type here.
                    if (doc.hasItem("$Title") &amp;&amp; doc.hasItem("$Flags")) {
                        type = TYPE_DESIGN;
                    }
                    else {
                        type = TYPE_DATA;
                    }
                }

                // check selection formulas
                if (TYPE_DESIGN == type) {
                    wantType = wantDesignNoteType(doc);
                    if (wantType) {
                        matchesFormula = (!si.hasDesignSelect()) ? true : matchesDesignSelection(session, si);
                    }
                }
                else {
                    wantType = true;
                    noteDescription = "Form: " + doc.getItemValueString("Form");
                    matchesFormula = (!si.hasSelect()) ? true : matchesSelectFormula(session, si.getSelectFormula());
                }

                return true;
            }
        }
    }

    public boolean wantType() {
        return wantType;
    }

    public boolean matchesFormula() {
        return matchesFormula;
    }

    private boolean stripUnwanted(Session session, ArrayList filters) throws Exception {
        if (filters.contains(ATTACH_FILTER_SEND_ALL)) {
            return true;
        }

        Vector v = session.evaluate("@AttachmentNames", doc);

        if (!v.isEmpty()) {
            for (int i = 0; i &lt; v.size(); i++) {
                String sAttachment = (String)v.elementAt(i);
                if (!sAttachment.equals("")) {
                    String sExt = sAttachment.substring(sAttachment.lastIndexOf('.') + 1);
                    if (!filters.contains(sExt.toLowerCase())) {
                        EmbeddedObject eo = doc.getAttachment(sAttachment);
                        eo.remove();
                    }
                }
            }
        }

        return true;
    }

    public String getNoteDxl(Session session, DxlExporter ex, Logger log) throws Exception {
        String noteXml = "";
        boolean needSendPurge = true;
        String unid = (TYPE_DELETION == type) ? id : doc.getUniversalID();
        HashSet deviceUnids = si.getDeviceUnidMap();
        if (null != deviceUnids) {
            if (!deviceUnids.contains(unid)) {
                needSendPurge = false;
            }
        }
        if (TYPE_DELETION == type) {
            if (needSendPurge) {
                noteXml = "&lt;tms:deletionStub unid='" + unid + "' /&gt;"; // Note that ls ag won't return del stubs if new pull
            }
            else {
                // noteXml = "&lt;tms:ignoredstub unid='" + unid + "' /&gt;";
            }
        }
        else {
            boolean omitAttachments = true;

            if (isNoteLoaded()) {

                if (wantType) {
                    if (matchesFormula) {
                        boolean forceNoteFormatSetting = ex.getForceNoteFormat();
                        ex.setForceNoteFormat(forceNoteFormat);

                        if (TYPE_DATA == type) {
                            if (si.hasAttachmentFilters()) {
                                omitAttachments = false;
                                ArrayList filters = si.getAttachmentFilters();
                                if (!stripUnwanted(session, filters)) {
                                    throw new TeamstudioException(ERR_ATTACH_FILTER_FAIL, ERR_ATTACH_FILTER_FAIL_MSG);
                                }
                            }

                            // we set exporter to desired settings then revert to defaults
                            boolean miscFileObjsSetting = ex.getOmitMiscFileObjects();
                            boolean richtextAttachmentsSetting = ex.getOmitRichtextAttachments();
                            int rtOptionSetting = ex.getRichTextOption();

                            ex.setOmitMiscFileObjects(omitAttachments);
                            ex.setOmitRichtextAttachments(omitAttachments);
                            ex.setRichTextOption(DxlExporter.DXLRICHTEXTOPTION_DXL);

                            try {
                                noteXml = transformXML(ex.exportDxl(doc));
                            }
                            catch (Exception e) {
                                if (null != log) {
                                    log.DebugWrite("\n" + ERRMSG_DXLEXPORTERRLOGMSG);
                                    log.DebugWrite(ex.getLog() + "\n");
                                }
                                throw new TeamstudioException(ERRMSG_DXLEXPORTFAILEDCHECKLOG, e);
                            }

                            ex.setOmitMiscFileObjects(miscFileObjsSetting); // reset in case there's ever another function that
                                                                            // expects original settings
                            ex.setOmitRichtextAttachments(richtextAttachmentsSetting);
                            ex.setRichTextOption(rtOptionSetting);

                        }
                        else {
                            // design
                            try {
                                noteXml = transformXML(ex.exportDxl(doc));
                            }
                            catch (Exception e) {
                                if (null != log) {
                                    log.DebugWrite("\n" + ERRMSG_DXLEXPORTERRLOGMSG);
                                    log.DebugWrite(ex.getLog() + "\n");
                                }
                                throw new TeamstudioException(ERRMSG_DXLEXPORTFAILEDCHECKLOG, e);
                            }
                        }

                        ex.setForceNoteFormat(forceNoteFormatSetting);

                        if (noteXml.startsWith("&lt;?xml version=")) {
                            noteXml = noteXml.substring(noteXml.indexOf("?&gt;") + "?&gt;".length());
                        }

                    }
                    else { // purge
                        if (needSendPurge) {
                            noteXml = "&lt;tms:purge unid='" + unid + "' /&gt;";
                        }
                        else {
                            // noteXml = "&lt;tms:ignoredpurge unid='" + unid + "' /&gt;";
                        }
                    }
                }

            }

        }
        return noteXml;
    }

    public void releaseDoc() throws NotesException {
        if (null != doc) {
            doc.recycle();
            doc = null;
        }
    }

    public boolean isNoteLoaded() {
        return (null != doc);
    }

    public int getType() {
        return type;
    }

    public void setType(int type) {
        this.type = type;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    private String transformXML(String xml) throws Exception {
        StringWriter writer = new StringWriter();
        Source xmlSource = new StreamSource(new StringReader(xml));
        Result result = new StreamResult(writer);
        Transformer trans = null;
        if (TYPE_DATA == type) {
            if (null == cachedDocumentXSLT) {
                Source xsltSource = new StreamSource(new StringReader(getXsl(true, si)));
                TransformerFactory transFact =
                        TransformerFactory.newInstance("org.apache.xalan.processor.TransformerFactoryImpl", null);
                cachedDocumentXSLT = transFact.newTemplates(xsltSource);
            }
            trans = cachedDocumentXSLT.newTransformer();
        }
        else {
            if (null == cachedXSLT) {
                Source xsltSource = new StreamSource(new StringReader(getXsl(false, si)));
                TransformerFactory transFact =
                        TransformerFactory.newInstance("org.apache.xalan.processor.TransformerFactoryImpl", null);
                cachedXSLT = transFact.newTemplates(xsltSource);
            }
            trans = cachedXSLT.newTransformer();
        }

        trans.transform(xmlSource, result);
        return writer.toString();
    }

    public String getNoteDescription() {
        return noteDescription;
    }

    private boolean matchesDesignName(WildcardPattern wp) throws NotesException {
        Vector titles = doc.getItemValue("$Title");
        for (int i = 0; i &lt; titles.size(); i++) { // loop all values (title and alias)
            String title = (String)titles.get(i);
            if (-1 == title.indexOf("|")) { // un-aliased
                if (wp.matches(title)) {
                    return true;
                }
            }
            else { // aliased
                String[] arrTitles = title.split("\\|");
                for (int y = 0; y &lt; arrTitles.length; y++) {
                    if (wp.matches(arrTitles[y])) {
                        return true;
                    }
                }
            }
        }
        return false; // no match
    }

    private boolean matchesDesignSelection(Session session, SessionInfo si) throws NotesException {

        if (!si.hasDesignSelect() || ("icon".equals(designNoteType))) {
            return true; // nothing to do.
        }

        Map designSelects = si.getDesignSelectElements();

        if ((!designSelects.containsKey(designNoteType)) &amp;&amp; (!designSelects.containsKey("all"))) {
            return true; // no select applies to this type so note should be sent.
        }

        Iterator iter = null;

        // check typed selects if any
        if (designSelects.containsKey(designNoteType)) {
            iter = ((ArrayList)designSelects.get(designNoteType)).iterator();
            while (iter.hasNext()) {
                DesignSelect ds = (DesignSelect)iter.next();
                if (matchesDesignSelect(session, ds)) {
                    return true;
                }
            }
        }

        // if no typed selects match, check globals
        if (designSelects.containsKey("all")) {
            iter = ((ArrayList)designSelects.get("all")).iterator();
            while (iter.hasNext()) {
                DesignSelect ds = (DesignSelect)iter.next();
                if (matchesDesignSelect(session, ds)) {
                    return true;
                }
            }
        }

        // if we're here, we did apply selects but didn't match so don't send note.
        return false;

    }

    private boolean matchesDesignSelect(Session session, DesignSelect ds) throws NotesException {
        // it applies to the current note
        if (ds.hasName()) {
            WildcardPattern wp = ds.getWc();
            if (matchesDesignName(wp) &amp;&amp; (!ds.hasFormula())) {
                designMatchInfo = ds.getType() + ": " + ds.getName();
                return true; // no formula to check
            }

        }
        // if we're here we either match on name (title) or there wasn't one (formula only)
        if (ds.hasFormula()) {
            String fmla = ds.getFormula();
            if (matchesSelectFormula(session, fmla)) {
                designMatchInfo = ds.getType() + ": " + ds.getFormula();
                return true;
            }
        }
        return false;
    }

    public boolean wantDesignNoteType(Document Note) throws NotesException {
        boolean fProcessNote = false;
        forceNoteFormat = false;

        if (Note.hasItem("$ViewFormat")) {
            noteDescription = "View: " + Note.getItemValueString("$Title");
            designNoteType = "view";
            fProcessNote = true;
        }
        else if (Note.hasItem("IconBitmap")) {
            noteDescription = "Icon Note";
            designNoteType = "icon";
            fProcessNote = true;
        }
        else {
            String title = Note.getItemValueString("$Title");
            String flags = Note.getItemValueString("$Flags");
            if ((flags.indexOf("g") &gt;= 0) &amp;&amp; (flags.indexOf("K") &gt;= 0)) {
                noteDescription = "XPage: " + title + "; flags=" + flags;
                designNoteType = "xpage";
                fProcessNote = true;
            }
            else if ((flags.indexOf("g") &gt;= 0) &amp;&amp; (flags.indexOf(";") &gt;= 0)) {
                noteDescription = "Custom Control: " + title + "; flags=" + flags;
                designNoteType = "customcontrol";
                fProcessNote = true;
            }
            else if (flags.indexOf("i") &gt;= 0) {
                Item item = Note.getFirstItem("$ImageData");
                long itmSize = item.getValueLength();
                // fProcessNote = null != item &amp;&amp; itmSize &lt; 512;
                fProcessNote = true; // now that we have chunking all images sent unless restricted by selection...
                noteDescription = "Image " + title + "; size=" + itmSize + "; flags=" + flags;
                designNoteType = "imageresource";
            }
            else if (flags.indexOf("h") &gt;= 0 || flags.indexOf(".") &gt;= 0) {
                noteDescription = "JavaScript Lib: " + title + "; flags=" + flags;
                designNoteType = "jslib";
                fProcessNote = true;
                if (flags.indexOf(".") &gt;= 0) {
                    forceNoteFormat = true;
                }
            }
            else if ((flags.indexOf("g") &gt;= 0) &amp;&amp; title.startsWith("unp/")) {
                noteDescription = "File Resource: " + title + "; flags=" + flags;
                designNoteType = "fileresource";
                fProcessNote = true;
            }
            else if (flags.indexOf("=") &gt;= 0) {
                noteDescription = "CSS Resource: " + title + "; flags=" + flags;
                designNoteType = "css";
                fProcessNote = true;
            }
            else {
                fProcessNote = false;
                noteDescription = "Non-Replicating: " + title + "; flags=" + flags;
                designNoteType = "other";
            }

        }
        return fProcessNote;
    }

    private static String getXsl(boolean isDataXsl, SessionInfo sessInf) {
        String rtTemplate = ""; // not set if design el
        if (isDataXsl) {
            rtTemplate =
                    "&lt;xsl:template match='dxl:item/dxl:richtext'&gt;" + "&lt;xsl:copy&gt;"
                            + "&lt;xsl:apply-templates select='@* | descendant::dxl:attachmentref' /&gt;" + "&lt;/xsl:copy&gt;"
                            + "&lt;/xsl:template&gt;";
            if (sessInf.hasAttachmentFilters()) {

                if (!sessInf.getAttachmentFilters().contains(ATTACH_FILTER_SEND_ALL)) {

                    Object[] filters = sessInf.getAttachmentFilters().toArray();
                    rtTemplate += "&lt;xsl:template match=\"dxl:richtext//dxl:attachmentref[";

                    for (int i = 0; i &lt; filters.length; i++) {
                        String filter = "." + (String)filters[i];
                        rtTemplate += i &gt; 0 ? " and " : "";
                        rtTemplate +=
                                "not( substring(@name, string-length(@name) - string-length('" + filter + "') +1) = '" + filter
                                        + "')";
                    }
                    rtTemplate += "]\" /&gt;";
                }
            }
            else {
                rtTemplate += "&lt;xsl:template match=\"dxl:richtext//dxl:attachmentref\" /&gt;";
            }
        }
        return "&lt;?xml version='1.0'?&gt;"
                + "&lt;xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' xmlns:dxl='http://www.lotus.com/dxl' version='1.0'&gt;"
                // testing only, format the xml -- breaks replicator test TestAllCharacters!
                // + "&lt;xsl:output method='xml' indent='yes' /&gt; &lt;!-- Format xml --&gt;"
                + "&lt;xsl:template match='@*|node()'&gt;"
                + "&lt;xsl:copy&gt;"
                + "&lt;xsl:apply-templates select='@*|node()'/&gt;"
                + "&lt;/xsl:copy&gt;"
                + "&lt;/xsl:template&gt;"
                /*
                 * // strip content for testing, comment out for normal use + "&lt;xsl:template match='" + "dxl:note" + "|dxl:page" +
                 * "|dxl:frameset" + "|dxl:noteinfo" + "|dxl:imageresource" + "|dxl:view" + "|dxl:stylesheetresource" +
                 * "|dxl:document'&gt;" + " &lt;xsl:call-template name='attribonly' /&gt; " + "&lt;/xsl:template&gt;"
                 * 
                 * + "&lt;xsl:template name='attribonly'&gt;" + "&lt;xsl:copy&gt;" + "&lt;xsl:apply-templates select='@*'/&gt;" +
                 * "&lt;xsl:apply-templates select='dxl:noteinfo|dxl:modified' /&gt;" + "&lt;/xsl:copy&gt;" + "&lt;/xsl:template&gt;" // end strip
                 * content
                 */

                + "&lt;xsl:template match='dxl:actionbar'/&gt;"

                // copy only last revision &gt;&gt; dxl:datetime[last()]
                + "&lt;xsl:template match='dxl:document/dxl:revisions'&gt;" + "&lt;xsl:copy&gt;"
                + "&lt;xsl:apply-templates select='@*|dxl:datetime[last()]'/&gt;" + "&lt;/xsl:copy&gt;" + "&lt;/xsl:template&gt;"

                + rtTemplate

                + ((isDataXsl) ? "&lt;xsl:template match='dxl:item[dxl:rawitemdata]' /&gt;" : "")
                + "&lt;xsl:template match='dxl:sharedactions'/&gt;" + "&lt;xsl:template match='dxl:acl'/&gt;"
                + "&lt;xsl:template match='dxl:item[starts-with(@name, \"$Class\")]' /&gt;"
                + "&lt;xsl:template match='dxl:code[dxl:lotusscript]' /&gt;" + "&lt;xsl:template match='dxl:globals' /&gt;"
                + "&lt;/xsl:stylesheet&gt;";
    }

    public boolean wantNote(boolean skipPurges) throws NotesException {
        if (skipPurges) {
            return (wantType() &amp;&amp; matchesFormula()); // we only want things that match if we're skip...
        }
        else {
            return wantType();
        }
    }

}
</java><java name='com/teamstudio/unplugged/libs/pv2/ReplicationNote.java'>package com.teamstudio.unplugged.libs.pv2;

import java.io.StringReader;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Vector;

import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import lotus.domino.Database;
import lotus.domino.Document;
import lotus.domino.DxlExporter;
import lotus.domino.EmbeddedObject;
import lotus.domino.Item;
import lotus.domino.NotesException;
import lotus.domino.RichTextItem;
import lotus.domino.Session;

import com.teamstudio.unplugged.libs.DesignSelect;
import com.teamstudio.unplugged.libs.IReplicationNote;
import com.teamstudio.unplugged.libs.Logger;
import com.teamstudio.unplugged.libs.Pull;
import com.teamstudio.unplugged.libs.SessionInfo;
import com.teamstudio.unplugged.libs.TeamstudioException;
import com.teamstudio.unplugged.libs.WildcardPattern;

public class ReplicationNote implements IReplicationNote {
    public static int FILE_FORMAT = 2;
    private static final String ERRMSG_DXLEXPORTERRLOGMSG =
            "** DXL Export Error: DXLExporter.exportDxl() returned the following error: ";
    private static final String ERRMSG_DXLEXPORTFAILEDCHECKLOG =
            "DXL Exporter error. Check the Unplugged server log Debugging Messages for details.";
    private static final String ERR_ATTACH_FILTER_FAIL_MSG = "Attempt to filter attachments failed!";
    private static final int ERR_ATTACH_FILTER_FAIL = 9899;
    private static final String ATTACH_FILTER_SEND_ALL = "*.*";

    private static Templates cachedXSLT;
    private static Templates cachedDocumentXSLT;
    private int type;
    private String id;
    private Document doc;
    private String noteDescription = "Not set";
    private boolean wantType;
    private boolean matchesFormula;
    private boolean forceNoteFormat;
    private SessionInfo si;
    private boolean hasError = false;
    private String designNoteType;
    private String designMatchInfo;
    private int currentClientFormat;

    public boolean hasError() {
        return hasError;
    }

    public String getTypeName() {
        String stype = "Unknown";
        switch (type) {
        case TYPE_DATA:
            stype = "DATA";
            break;
        case TYPE_DESIGN:
            stype = "DSGN";
            break;
        case TYPE_DELETION:
            stype = "DEL";
            break;
        }
        return stype;
    }

    public String toString() {
        return getTypeName() + ": " + id + "; Matches: " + matchesFormula
                + ((null != designMatchInfo) ? (" (" + designMatchInfo + ")") : "") + ";  " + noteDescription;
    }

    public static int getTypeFromFirstChar(String ID) {
        int retval = TYPE_UNKNOWN;
        char first = ID.charAt(0);
        switch (first) {
        case 'z':
            retval = TYPE_DESIGN;
            break;
        case 'x':
            retval = TYPE_DELETION;
            break;
        case 'y':
            retval = TYPE_DATA;
            break;

        case 'u':
            retval = TYPE_UNKNOWN;
            break;
        }
        return retval;
    }

    public ReplicationNote(String IDWithTypePrefix, SessionInfo SI, int currentFormat) {
        super();
        if ((null == IDWithTypePrefix) || (1 &gt; IDWithTypePrefix.length())) {
            return;
        }
        type = getTypeFromFirstChar(IDWithTypePrefix);
        id = IDWithTypePrefix.substring(1);
        si = SI;
        currentClientFormat = currentFormat; // Needed to decide what data needs resend...
    }

    public boolean matchesSelectFormula(Session session, String sFmla) {
        Object doesMatch;
        try {
            doesMatch = session.evaluate(sFmla, doc).elementAt(0);
            if (doesMatch instanceof Double &amp;&amp; ((Double)doesMatch).doubleValue() != 0) {
                return true;
            }
            return false;

        }
        catch (NotesException e) {
            noteDescription += " FORMULA EVAL FAILED!";
            return false;
        }
    }

    public boolean loadDoc(Session session, Database db) throws NotesException {
        if (TYPE_DELETION == type) {
            noteDescription = "Deletion Stub";
            wantType = true;
            matchesFormula = true;
            return true;
        }
        else {
            try {
                doc = db.getDocumentByID(id);
            }
            catch (NotesException ex) {
                ex.printStackTrace();
                noteDescription = "Error loading note: " + ex.id + ":" + ex.text;
                hasError = true;
            }
            if (null == doc) {
                if (!hasError) { // don't overwrite if error included...
                    noteDescription = "Not loaded; Reader field protected or no longer available.";
                }
                return false;
            }
            else {
                if (TYPE_UNKNOWN == type) { // if the type was unknown when created, find type here.
                    if (doc.hasItem("$Title") &amp;&amp; doc.hasItem("$Flags")) {
                        type = TYPE_DESIGN;
                    }
                    else {
                        type = TYPE_DATA;
                    }
                }

                // check selection formulas
                if (TYPE_DESIGN == type) {
                    wantType = wantDesignNoteType(doc);
                    if (wantType) {
                        matchesFormula = (!si.hasDesignSelect()) ? true : matchesDesignSelection(session, si);
                    }
                }
                else {
                    wantType = true;
                    noteDescription = "Form: " + doc.getItemValueString("Form");
                    matchesFormula = (!si.hasSelect()) ? true : matchesSelectFormula(session, si.getSelectFormula());
                }

                return true;
            }
        }
    }

    public boolean wantType() {
        return wantType;
    }

    public boolean matchesFormula() {
        return matchesFormula;
    }

    private boolean stripUnwanted(Session session, ArrayList filters) throws Exception {
        if (filters.contains(ATTACH_FILTER_SEND_ALL)) {
            return true;
        }

        Vector v = session.evaluate("@AttachmentNames", doc);

        if (!v.isEmpty()) {
            for (int i = 0; i &lt; v.size(); i++) {
                String sAttachment = (String)v.elementAt(i);
                if (!sAttachment.equals("")) {
                    String sExt = sAttachment.substring(sAttachment.lastIndexOf('.') + 1);
                    if (!filters.contains(sExt.toLowerCase())) {
                        EmbeddedObject eo = doc.getAttachment(sAttachment);
                        eo.remove();
                    }
                }
            }
        }

        return true;
    }

    public String getNoteDxl(Session session, DxlExporter ex, Logger log) throws Exception {
        String noteXml = "";
        boolean needSendPurge = true;
        String unid = (TYPE_DELETION == type) ? id : doc.getUniversalID();
        HashSet deviceUnids = si.getDeviceUnidMap();
        if (null != deviceUnids) {
            if (!deviceUnids.contains(unid)) {
                needSendPurge = false;
            }
        }
        if (TYPE_DELETION == type) {
            if (needSendPurge) {
                noteXml = "&lt;tms:deletionStub unid='" + unid + "' /&gt;"; // Note that ls ag won't return del stubs if new pull
            }
            else {
                // noteXml = "&lt;tms:ignoredstub unid='" + unid + "' /&gt;";
            }
        }
        else {
            boolean omitAttachments = true;

            if (isNoteLoaded()) {

                if (wantType) {
                    if (matchesFormula) {
                        boolean forceNoteFormatSetting = ex.getForceNoteFormat();
                        ex.setForceNoteFormat(forceNoteFormat);

                        if (TYPE_DATA == type) {
                            if (si.hasAttachmentFilters()) {
                                omitAttachments = false;
                                ArrayList filters = si.getAttachmentFilters();
                                if (!stripUnwanted(session, filters)) {
                                    throw new TeamstudioException(ERR_ATTACH_FILTER_FAIL, ERR_ATTACH_FILTER_FAIL_MSG);
                                }
                            }

                            // CONVERT MIME for RT handling
                            Vector items = doc.getItems();
                            for (int i = 0; i &lt; items.size(); i++) {
                                Item item = (Item)items.get(i);
                                if (item instanceof RichTextItem) {
                                    RichTextItem rti = (RichTextItem)item;
                                    rti.appendText("");
                                    rti.update();
                                    rti.compact();
                                }
                            }

                            // we set exporter to desired settings then revert to defaults
                            boolean miscFileObjsSetting = ex.getOmitMiscFileObjects();
                            boolean richtextAttachmentsSetting = ex.getOmitRichtextAttachments();
                            boolean pictsSetting = ex.getOmitRichtextPictures();
                            boolean bmpSetting = ex.getConvertNotesBitmapsToGIF();
                            int rtOptionSetting = ex.getRichTextOption();

                            ex.setOmitMiscFileObjects(omitAttachments);
                            ex.setOmitRichtextAttachments(omitAttachments);
                            ex.setOmitRichtextPictures(false);
                            ex.setConvertNotesBitmapsToGIF(true);
                            ex.setRichTextOption(DxlExporter.DXLRICHTEXTOPTION_DXL);

                            try {
                                noteXml = transformXML(ex.exportDxl(doc));
                            }
                            catch (Exception e) {
                                if (null != log) {
                                    log.DebugWrite("\n" + ERRMSG_DXLEXPORTERRLOGMSG);
                                    log.DebugWrite(ex.getLog() + "\n");
                                }
                                throw new TeamstudioException(ERRMSG_DXLEXPORTFAILEDCHECKLOG, e);
                            }

                            ex.setOmitMiscFileObjects(miscFileObjsSetting); // reset in case there's ever another function that
                            // expects original settings
                            ex.setOmitRichtextAttachments(richtextAttachmentsSetting);
                            ex.setOmitRichtextPictures(pictsSetting);
                            ex.setConvertNotesBitmapsToGIF(bmpSetting);
                            ex.setRichTextOption(rtOptionSetting);

                        }
                        else {
                            // design
                            try {
                                noteXml = transformXML(ex.exportDxl(doc));
                            }
                            catch (Exception e) {
                                if (null != log) {
                                    log.DebugWrite("\n" + ERRMSG_DXLEXPORTERRLOGMSG);
                                    log.DebugWrite(ex.getLog() + "\n");
                                }
                                throw new TeamstudioException(ERRMSG_DXLEXPORTFAILEDCHECKLOG, e);
                            }
                        }

                        ex.setForceNoteFormat(forceNoteFormatSetting);

                        if (noteXml.startsWith("&lt;?xml version=")) {
                            noteXml = noteXml.substring(noteXml.indexOf("?&gt;") + "?&gt;".length());
                        }

                    }
                    else { // purge
                        if (needSendPurge) {
                            noteXml = "&lt;tms:purge unid='" + unid + "' /&gt;";
                        }
                        else {
                            // noteXml = "&lt;tms:ignoredpurge unid='" + unid + "' /&gt;";
                        }
                    }
                }

            }

        }
        return noteXml;
    }

    public void releaseDoc() throws NotesException {
        if (null != doc) {
            doc.recycle();
            doc = null;
        }
    }

    public boolean isNoteLoaded() {
        return (null != doc);
    }

    public int getType() {
        return type;
    }

    public void setType(int type) {
        this.type = type;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    private String transformXML(String xml) throws Exception {
        StringWriter writer = new StringWriter();
        Source xmlSource = new StreamSource(new StringReader(xml));
        Result result = new StreamResult(writer);
        Transformer trans = null;
        if (TYPE_DATA == type) {
            if (null == cachedDocumentXSLT) {
                Source xsltSource = new StreamSource(new StringReader(getXsl(true, si)));
                TransformerFactory transFact =
                        TransformerFactory.newInstance("org.apache.xalan.processor.TransformerFactoryImpl", null);
                cachedDocumentXSLT = transFact.newTemplates(xsltSource);
            }
            trans = cachedDocumentXSLT.newTransformer();
        }
        else {
            if (null == cachedXSLT) {
                Source xsltSource = new StreamSource(new StringReader(getXsl(false, si)));
                TransformerFactory transFact =
                        TransformerFactory.newInstance("org.apache.xalan.processor.TransformerFactoryImpl", null);
                cachedXSLT = transFact.newTemplates(xsltSource);
            }
            trans = cachedXSLT.newTransformer();
        }

        trans.transform(xmlSource, result);
        return writer.toString();
    }

    public String getNoteDescription() {
        return noteDescription;
    }

    private boolean matchesDesignName(WildcardPattern wp) throws NotesException {
        Vector titles = doc.getItemValue("$Title");
        for (int i = 0; i &lt; titles.size(); i++) { // loop all values (title and alias)
            String title = (String)titles.get(i);
            if (-1 == title.indexOf("|")) { // un-aliased
                if (wp.matches(title)) {
                    return true;
                }
            }
            else { // aliased
                String[] arrTitles = title.split("\\|");
                for (int y = 0; y &lt; arrTitles.length; y++) {
                    if (wp.matches(arrTitles[y])) {
                        return true;
                    }
                }
            }
        }
        return false; // no match
    }

    private boolean matchesDesignSelection(Session session, SessionInfo si) throws NotesException {

        if (!si.hasDesignSelect() || ("icon".equals(designNoteType))) {
            return true; // nothing to do.
        }

        Map designSelects = si.getDesignSelectElements();

        if ((!designSelects.containsKey(designNoteType)) &amp;&amp; (!designSelects.containsKey("all"))) {
            return true; // no select applies to this type so note should be sent.
        }

        Iterator iter = null;

        // check typed selects if any
        if (designSelects.containsKey(designNoteType)) {
            iter = ((ArrayList)designSelects.get(designNoteType)).iterator();
            while (iter.hasNext()) {
                DesignSelect ds = (DesignSelect)iter.next();
                if (matchesDesignSelect(session, ds)) {
                    return true;
                }
            }
        }

        // if no typed selects match, check globals
        if (designSelects.containsKey("all")) {
            iter = ((ArrayList)designSelects.get("all")).iterator();
            while (iter.hasNext()) {
                DesignSelect ds = (DesignSelect)iter.next();
                if (matchesDesignSelect(session, ds)) {
                    return true;
                }
            }
        }

        // if we're here, we did apply selects but didn't match so don't send note.
        return false;

    }

    private boolean matchesDesignSelect(Session session, DesignSelect ds) throws NotesException {
        // it applies to the current note
        if (ds.hasName()) {
            WildcardPattern wp = ds.getWc();
            if (matchesDesignName(wp) &amp;&amp; (!ds.hasFormula())) {
                designMatchInfo = ds.getType() + ": " + ds.getName();
                return true; // no formula to check
            }

        }
        // if we're here we either match on name (title) or there wasn't one (formula only)
        if (ds.hasFormula()) {
            String fmla = ds.getFormula();
            if (matchesSelectFormula(session, fmla)) {
                designMatchInfo = ds.getType() + ": " + ds.getFormula();
                return true;
            }
        }
        return false;
    }

    public boolean wantDesignNoteType(Document Note) throws NotesException {
        boolean fProcessNote = false;
        forceNoteFormat = false;

        if (Note.hasItem("$ViewFormat")) {
            noteDescription = "View: " + Note.getItemValueString("$Title");
            designNoteType = "view";
            fProcessNote = true;
        }
        else if (Note.hasItem("IconBitmap")) {
            noteDescription = "Icon Note";
            designNoteType = "icon";
            fProcessNote = true;
        }
        else {
            String title = Note.getItemValueString("$Title");
            String flags = Note.getItemValueString("$Flags");
            if ((flags.indexOf("g") &gt;= 0) &amp;&amp; (flags.indexOf("K") &gt;= 0)) {
                noteDescription = "XPage: " + title + "; flags=" + flags;
                designNoteType = "xpage";
                fProcessNote = true;
            }
            else if ((flags.indexOf("g") &gt;= 0) &amp;&amp; (flags.indexOf(";") &gt;= 0)) {
                noteDescription = "Custom Control: " + title + "; flags=" + flags;
                designNoteType = "customcontrol";
                fProcessNote = true;
            }
            else if (flags.indexOf("i") &gt;= 0) {
                Item item = Note.getFirstItem("$ImageData");
                long itmSize = item.getValueLength();
                // fProcessNote = null != item &amp;&amp; itmSize &lt; 512;
                fProcessNote = true; // now that we have chunking all images sent unless restricted by selection...
                noteDescription = "Image " + title + "; size=" + itmSize + "; flags=" + flags;
                designNoteType = "imageresource";
            }
            else if (flags.indexOf("h") &gt;= 0 || flags.indexOf(".") &gt;= 0) {
                noteDescription = "JavaScript Lib: " + title + "; flags=" + flags;
                designNoteType = "jslib";
                fProcessNote = true;
                if (flags.indexOf(".") &gt;= 0) {
                    forceNoteFormat = true;
                }
            }
            else if ((flags.indexOf("g") &gt;= 0)  &amp;&amp; title.startsWith("unp/")) {
                noteDescription = "File Resource: " + title + "; flags=" + flags;
                designNoteType = "fileresource";
                fProcessNote = true;
            }
            else if (flags.indexOf("=") &gt;= 0) {
                noteDescription = "CSS Resource: " + title + "; flags=" + flags;
                designNoteType = "css";
                fProcessNote = true;
            }
            else {
                fProcessNote = false;
                noteDescription = "Non-Replicating: " + title + "; flags=" + flags;
                designNoteType = "other";
            }

        }
        return fProcessNote;
    }

    private static String getXsl(boolean isDataXsl, SessionInfo sessInf) {
        String rtTemplate = ""; // not set if design el
        if (isDataXsl) {
            rtTemplate = "&lt;xsl:template match='dxl:item/dxl:richtext'&gt;" + "&lt;xsl:copy&gt;"
            // TODO assess rt handling w attach limit!
            // + "&lt;xsl:apply-templates select='@* | descendant::dxl:attachmentref' /&gt;" + "&lt;/xsl:copy&gt;"
                    + "&lt;xsl:apply-templates select='@*|node()' /&gt;" + "&lt;/xsl:copy&gt;" + "&lt;/xsl:template&gt;";
            if (sessInf.hasAttachmentFilters()) {

                if (!sessInf.getAttachmentFilters().contains(ATTACH_FILTER_SEND_ALL)) {

                    Object[] filters = sessInf.getAttachmentFilters().toArray();
                    rtTemplate += "&lt;xsl:template match=\"dxl:richtext//dxl:attachmentref[";

                    for (int i = 0; i &lt; filters.length; i++) {
                        String filter = "." + (String)filters[i];
                        rtTemplate += i &gt; 0 ? " and " : "";
                        rtTemplate +=
                                "not( substring(@name, string-length(@name) - string-length('" + filter + "') +1) = '" + filter
                                        + "')";
                    }
                    rtTemplate += "]\" /&gt;";
                }
            }
            else {
                // rtTemplate += "&lt;xsl:template match=\"dxl:richtext//dxl:attachmentref\" /&gt;";
            }
            Pull.writeDebug("*****************rtTemplate*****************");
            Pull.writeDebug(rtTemplate);
            Pull.writeDebug("********************************************");
        }
        return "&lt;?xml version='1.0'?&gt;"
                + "&lt;xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' xmlns:dxl='http://www.lotus.com/dxl' version='1.0'&gt;"
                // testing only, format the xml -- breaks replicator test TestAllCharacters!
                // + "&lt;xsl:output method='xml' indent='yes' /&gt; &lt;!-- Format xml --&gt;"
                + "&lt;xsl:template match='@*|node()'&gt;" + "&lt;xsl:copy&gt;"
                + "&lt;xsl:apply-templates select='@*|node()'/&gt;"
                + "&lt;/xsl:copy&gt;"
                + "&lt;/xsl:template&gt;"
                /*
                 * // strip content for testing, comment out for normal use + "&lt;xsl:template match='" + "dxl:note" + "|dxl:page" +
                 * "|dxl:frameset" + "|dxl:noteinfo" + "|dxl:imageresource" + "|dxl:view" + "|dxl:stylesheetresource" +
                 * "|dxl:document'&gt;" + " &lt;xsl:call-template name='attribonly' /&gt; " + "&lt;/xsl:template&gt;"
                 * 
                 * + "&lt;xsl:template name='attribonly'&gt;" + "&lt;xsl:copy&gt;" + "&lt;xsl:apply-templates select='@*'/&gt;" +
                 * "&lt;xsl:apply-templates select='dxl:noteinfo|dxl:modified' /&gt;" + "&lt;/xsl:copy&gt;" + "&lt;/xsl:template&gt;" // end strip
                 * content
                 */

                + "&lt;xsl:template match='dxl:actionbar'/&gt;"

                + rtTemplate

                // copy only last revision &gt;&gt; dxl:datetime[last()]
                + "&lt;xsl:template match='dxl:document/dxl:revisions'&gt;" + "&lt;xsl:copy&gt;"
                + "&lt;xsl:apply-templates select='@*|dxl:datetime[last()]'/&gt;" + "&lt;/xsl:copy&gt;" + "&lt;/xsl:template&gt;"

                + ((isDataXsl) ? "&lt;xsl:template match='dxl:item[dxl:rawitemdata]' /&gt;" : "")
                + "&lt;xsl:template match='dxl:sharedactions'/&gt;" + "&lt;xsl:template match='dxl:acl'/&gt;"
                + "&lt;xsl:template match='dxl:item[starts-with(@name, \"$Class\")]' /&gt;"
                + "&lt;xsl:template match='dxl:code[dxl:lotusscript]' /&gt;" + "&lt;xsl:template match='dxl:globals' /&gt;"
                + "&lt;/xsl:stylesheet&gt;";
    }

    public boolean wantNote(boolean skipPurges) throws NotesException {
        if (si.isForceUpgrade() &amp;&amp; (!si.isFirstPull())) {
            if (!wantNoteForUpgrade()) {
                return false;
            }
        }
        if (skipPurges) {
            return (wantType() &amp;&amp; matchesFormula()); // we only want things that match if we're skip...
        }
        else {
            return wantType();
        }
    }

    private boolean wantNoteForUpgrade() throws NotesException {
    	if(IReplicationNote.TYPE_DELETION == type){
    		return true;  //THE LS/API code date checks deletions and only includes if they are after sinceTime...
    	}
    	
        if (0 &lt;= doc.getLastModified().timeDifferenceDouble(si.getSinceNotes())) {
//            Pull.writeDebug(type + "  IS MOD since pull, sending: " + id + ";  FORM: " + doc.getItemValueString("Form")
//                    + "; $Flags: " + doc.getItemValueString("$Flags")
//                    + " doc Last Mod: " + doc.getLastModified().getLocalTime() 
//                    + " sinceNotes: " + si.getSinceNotes().getLocalTime()
//                    + " tdd: " + doc.getLastModified().timeDifferenceDouble(si.getSinceNotes())
//                    + "\n lastModJava: " + doc.getLastModified().toJavaDate().getTime() 
//                    + " since as java" + si.getSinceNotes().toJavaDate().getTime()
//            );
            return true;
        }
        
        if (IReplicationNote.TYPE_DATA == type) {
            Vector itms = doc.getItems();
            if (!itms.isEmpty()) {
                for (int i = 0; i &lt; itms.size(); i++) {
                    Item itm = (Item)itms.elementAt(i);
                    if (Item.RICHTEXT == itm.getType()) {
                        Pull.writeDebug("Resending document required for upgrade: " + id + ";  FORM: " + doc.getItemValueString("Form"));
                        return true;
                    }
                }
            }

            si.upgradeDataNoteSkipped();
//            Pull.writeDebug(type + " NOT needing update: " + id + ";  FORM: " + doc.getItemValueString("Form") + "; $Flags: "
//                    + doc.getItemValueString("$Flags"));
        }
        else {
        	si.upgradeDesignNoteSkipped();
//            Pull.writeDebug(type + "  DSGN NOT needing update: " + id + ";  $Title: " + doc.getItemValueString("$Title")
//                    + "; $Flags: " + doc.getItemValueString("$Flags"));
        }

        return false;
    }

}
</java><java name='com/teamstudio/unplugged/libs/pv3/ReplicationNote.java'>package com.teamstudio.unplugged.libs.pv3;

import java.io.StringReader;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Vector;

import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import lotus.domino.Database;
import lotus.domino.Document;
import lotus.domino.DxlExporter;
import lotus.domino.EmbeddedObject;
import lotus.domino.Item;
import lotus.domino.NotesException;
import lotus.domino.RichTextItem;
import lotus.domino.Session;

import com.teamstudio.unplugged.libs.DesignSelect;
import com.teamstudio.unplugged.libs.IReplicationNote;
import com.teamstudio.unplugged.libs.Logger;
import com.teamstudio.unplugged.libs.Pull;
import com.teamstudio.unplugged.libs.SessionInfo;
import com.teamstudio.unplugged.libs.TeamstudioException;
import com.teamstudio.unplugged.libs.WildcardPattern;

public class ReplicationNote implements IReplicationNote {
    public static int FILE_FORMAT = 2;
    private static final String ERRMSG_DXLEXPORTERRLOGMSG =
            "** DXL Export Error: DXLExporter.exportDxl() returned the following error: ";
    private static final String ERRMSG_DXLEXPORTFAILEDCHECKLOG =
            "DXL Exporter error. Check the Unplugged server log Debugging Messages for details.";
    private static final String ERR_ATTACH_FILTER_FAIL_MSG = "Attempt to filter attachments failed!";
    private static final int ERR_ATTACH_FILTER_FAIL = 9899;
    private static final String ATTACH_FILTER_SEND_ALL = "*.*";

    private static Templates cachedXSLT;
    private static Templates cachedDocumentXSLT;
    private int type;
    private String id;
    private Document doc;
    private String noteDescription = "Not set";
    private boolean wantType;
    private boolean matchesFormula;
    private boolean forceNoteFormat;
    private SessionInfo si;
    private boolean hasError = false;
    private String designNoteType;
    private String designMatchInfo;
    private int currentClientFormat;

    public boolean hasError() {
        return hasError;
    }

    public String getTypeName() {
        String stype = "Unknown";
        switch (type) {
        case TYPE_DATA:
            stype = "DATA";
            break;
        case TYPE_DESIGN:
            stype = "DSGN";
            break;
        case TYPE_DELETION:
            stype = "DEL";
            break;
        }
        return stype;
    }

    public String toString() {
        return getTypeName() + ": " + id + "; Matches: " + matchesFormula
                + ((null != designMatchInfo) ? (" (" + designMatchInfo + ")") : "") + ";  " + noteDescription;
    }

    public static int getTypeFromFirstChar(String ID) {
        int retval = TYPE_UNKNOWN;
        char first = ID.charAt(0);
        switch (first) {
        case 'z':
            retval = TYPE_DESIGN;
            break;
        case 'x':
            retval = TYPE_DELETION;
            break;
        case 'y':
            retval = TYPE_DATA;
            break;

        case 'u':
            retval = TYPE_UNKNOWN;
            break;
        }
        return retval;
    }

    public ReplicationNote(String IDWithTypePrefix, SessionInfo SI, int currentFormat) {
        super();
        if ((null == IDWithTypePrefix) || (1 &gt; IDWithTypePrefix.length())) {
            return;
        }
        type = getTypeFromFirstChar(IDWithTypePrefix);
        id = IDWithTypePrefix.substring(1);
        si = SI;
        currentClientFormat = currentFormat; // Needed to decide what data needs resend...
    }

    public boolean matchesSelectFormula(Session session, String sFmla) {
        Object doesMatch;
        try {
            doesMatch = session.evaluate(sFmla, doc).elementAt(0);
            if (doesMatch instanceof Double &amp;&amp; ((Double)doesMatch).doubleValue() != 0) {
                return true;
            }
            return false;

        }
        catch (NotesException e) {
            noteDescription += " FORMULA EVAL FAILED!";
            return false;
        }
    }

    public boolean loadDoc(Session session, Database db) throws NotesException {
        if (TYPE_DELETION == type) {
            noteDescription = "Deletion Stub";
            wantType = true;
            matchesFormula = true;
            return true;
        }
        else {
            try {
                doc = db.getDocumentByID(id);
            }
            catch (NotesException ex) {
                ex.printStackTrace();
                noteDescription = "Error loading note: " + ex.id + ":" + ex.text;
                hasError = true;
            }
            if (null == doc) {
                if (!hasError) { // don't overwrite if error included...
                    noteDescription = "Not loaded; Reader field protected or no longer available.";
                }
                return false;
            }
            else {
                if (TYPE_UNKNOWN == type) { // if the type was unknown when created, find type here.
                    if (doc.hasItem("$Title") &amp;&amp; doc.hasItem("$Flags")) {
                        type = TYPE_DESIGN;
                    }
                    else {
                        type = TYPE_DATA;
                    }
                }

                // check selection formulas
                if (TYPE_DESIGN == type) {
                    wantType = wantDesignNoteType(doc);
                    if (wantType) {
                        matchesFormula = (!si.hasDesignSelect()) ? true : matchesDesignSelection(session, si);
                    }
                }
                else {
                    wantType = true;
                    noteDescription = "Form: " + doc.getItemValueString("Form");
                    matchesFormula = (!si.hasSelect()) ? true : matchesSelectFormula(session, si.getSelectFormula());
                }

                return true;
            }
        }
    }

    public boolean wantType() {
        return wantType;
    }

    public boolean matchesFormula() {
        return matchesFormula;
    }

    private boolean stripUnwanted(Session session, ArrayList filters) throws Exception {
        if (filters.contains(ATTACH_FILTER_SEND_ALL)) {
            return true;
        }

        Vector v = session.evaluate("@AttachmentNames", doc);

        if (!v.isEmpty()) {
            for (int i = 0; i &lt; v.size(); i++) {
                String sAttachment = (String)v.elementAt(i);
                if (!sAttachment.equals("")) {
                    String sExt = sAttachment.substring(sAttachment.lastIndexOf('.') + 1);
                    if (!filters.contains(sExt.toLowerCase())) {
                        EmbeddedObject eo = doc.getAttachment(sAttachment);
                        eo.remove();
                    }
                }
            }
        }

        return true;
    }

    public String getNoteDxl(Session session, DxlExporter ex, Logger log) throws Exception {
        String noteXml = "";
        boolean needSendPurge = true;
        String unid = (TYPE_DELETION == type) ? id : doc.getUniversalID();
        HashSet deviceUnids = si.getDeviceUnidMap();
        if (null != deviceUnids) {
            if (!deviceUnids.contains(unid)) {
                needSendPurge = false;
            }
        }
        if (TYPE_DELETION == type) {
            if (needSendPurge) {
                noteXml = "&lt;tms:deletionStub unid='" + unid + "' /&gt;"; // Note that ls ag won't return del stubs if new pull
            }
            else {
                // noteXml = "&lt;tms:ignoredstub unid='" + unid + "' /&gt;";
            }
        }
        else {
            boolean omitAttachments = true;

            if (isNoteLoaded()) {

                if (wantType) {
                    if (matchesFormula) {
                        boolean forceNoteFormatSetting = ex.getForceNoteFormat();
                        ex.setForceNoteFormat(forceNoteFormat);

                        if (TYPE_DATA == type) {
                            if (si.hasAttachmentFilters()) {
                                omitAttachments = false;
                                ArrayList filters = si.getAttachmentFilters();
                                if (!stripUnwanted(session, filters)) {
                                    throw new TeamstudioException(ERR_ATTACH_FILTER_FAIL, ERR_ATTACH_FILTER_FAIL_MSG);
                                }
                            }

                            // CONVERT MIME for RT handling
                            Vector items = doc.getItems();
                            for (int i = 0; i &lt; items.size(); i++) {
                                Item item = (Item)items.get(i);
                                if (item instanceof RichTextItem) {
                                    RichTextItem rti = (RichTextItem)item;
                                    rti.appendText("");
                                    rti.update();
                                    rti.compact();
                                }
                            }

                            // we set exporter to desired settings then revert to defaults
                            boolean miscFileObjsSetting = ex.getOmitMiscFileObjects();
                            boolean richtextAttachmentsSetting = ex.getOmitRichtextAttachments();
                            boolean pictsSetting = ex.getOmitRichtextPictures();
                            boolean bmpSetting = ex.getConvertNotesBitmapsToGIF();
                            int rtOptionSetting = ex.getRichTextOption();

                            ex.setOmitMiscFileObjects(omitAttachments);
                            ex.setOmitRichtextAttachments(omitAttachments);
                            ex.setOmitRichtextPictures(false);
                            ex.setConvertNotesBitmapsToGIF(true);
                            ex.setRichTextOption(DxlExporter.DXLRICHTEXTOPTION_DXL);

                            try {
                                noteXml = transformXML(ex.exportDxl(doc));
                            }
                            catch (Exception e) {
                                if (null != log) {
                                    log.DebugWrite("\n" + ERRMSG_DXLEXPORTERRLOGMSG);
                                    log.DebugWrite(ex.getLog() + "\n");
                                }
                                throw new TeamstudioException(ERRMSG_DXLEXPORTFAILEDCHECKLOG, e);
                            }

                            ex.setOmitMiscFileObjects(miscFileObjsSetting); // reset in case there's ever another function that
                            // expects original settings
                            ex.setOmitRichtextAttachments(richtextAttachmentsSetting);
                            ex.setOmitRichtextPictures(pictsSetting);
                            ex.setConvertNotesBitmapsToGIF(bmpSetting);
                            ex.setRichTextOption(rtOptionSetting);

                        }
                        else {
                            // design
                            try {
                                noteXml = transformXML(ex.exportDxl(doc));
                            }
                            catch (Exception e) {
                                if (null != log) {
                                    log.DebugWrite("\n" + ERRMSG_DXLEXPORTERRLOGMSG);
                                    log.DebugWrite(ex.getLog() + "\n");
                                }
                                throw new TeamstudioException(ERRMSG_DXLEXPORTFAILEDCHECKLOG, e);
                            }
                        }

                        ex.setForceNoteFormat(forceNoteFormatSetting);

                        if (noteXml.startsWith("&lt;?xml version=")) {
                            noteXml = noteXml.substring(noteXml.indexOf("?&gt;") + "?&gt;".length());
                        }

                    }
                    else { // purge
                        if (needSendPurge) {
                            noteXml = "&lt;tms:purge unid='" + unid + "' /&gt;";
                        }
                        else {
                            // noteXml = "&lt;tms:ignoredpurge unid='" + unid + "' /&gt;";
                        }
                    }
                }

            }

        }
        return noteXml;
    }

    public void releaseDoc() throws NotesException {
        if (null != doc) {
            doc.recycle();
            doc = null;
        }
    }

    public boolean isNoteLoaded() {
        return (null != doc);
    }

    public int getType() {
        return type;
    }

    public void setType(int type) {
        this.type = type;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    private String transformXML(String xml) throws Exception {
        StringWriter writer = new StringWriter();
        Source xmlSource = new StreamSource(new StringReader(xml));
        Result result = new StreamResult(writer);
        Transformer trans = null;
        if (TYPE_DATA == type) {
            if (null == cachedDocumentXSLT) {
                Source xsltSource = new StreamSource(new StringReader(getXsl(true, si)));
                TransformerFactory transFact =
                        TransformerFactory.newInstance("org.apache.xalan.processor.TransformerFactoryImpl", null);
                cachedDocumentXSLT = transFact.newTemplates(xsltSource);
            }
            trans = cachedDocumentXSLT.newTransformer();
        }
        else {
            if (null == cachedXSLT) {
                Source xsltSource = new StreamSource(new StringReader(getXsl(false, si)));
                TransformerFactory transFact =
                        TransformerFactory.newInstance("org.apache.xalan.processor.TransformerFactoryImpl", null);
                cachedXSLT = transFact.newTemplates(xsltSource);
            }
            trans = cachedXSLT.newTransformer();
        }

        trans.transform(xmlSource, result);
        return writer.toString();
    }

    public String getNoteDescription() {
        return noteDescription;
    }

    private boolean matchesDesignName(WildcardPattern wp) throws NotesException {
        Vector titles = doc.getItemValue("$Title");
        for (int i = 0; i &lt; titles.size(); i++) { // loop all values (title and alias)
            String title = (String)titles.get(i);
            if (-1 == title.indexOf("|")) { // un-aliased
                if (wp.matches(title)) {
                    return true;
                }
            }
            else { // aliased
                String[] arrTitles = title.split("\\|");
                for (int y = 0; y &lt; arrTitles.length; y++) {
                    if (wp.matches(arrTitles[y])) {
                        return true;
                    }
                }
            }
        }
        return false; // no match
    }

    private boolean matchesDesignSelection(Session session, SessionInfo si) throws NotesException {

        if (!si.hasDesignSelect() || ("icon".equals(designNoteType))) {
            return true; // nothing to do.
        }

        Map designSelects = si.getDesignSelectElements();

        if ((!designSelects.containsKey(designNoteType)) &amp;&amp; (!designSelects.containsKey("all"))) {
            return true; // no select applies to this type so note should be sent.
        }

        Iterator iter = null;

        // check typed selects if any
        if (designSelects.containsKey(designNoteType)) {
            iter = ((ArrayList)designSelects.get(designNoteType)).iterator();
            while (iter.hasNext()) {
                DesignSelect ds = (DesignSelect)iter.next();
                if (matchesDesignSelect(session, ds)) {
                    return true;
                }
            }
        }

        // if no typed selects match, check globals
        if (designSelects.containsKey("all")) {
            iter = ((ArrayList)designSelects.get("all")).iterator();
            while (iter.hasNext()) {
                DesignSelect ds = (DesignSelect)iter.next();
                if (matchesDesignSelect(session, ds)) {
                    return true;
                }
            }
        }

        // if we're here, we did apply selects but didn't match so don't send note.
        return false;

    }

    private boolean matchesDesignSelect(Session session, DesignSelect ds) throws NotesException {
        // it applies to the current note
        if (ds.hasName()) {
            WildcardPattern wp = ds.getWc();
            if (matchesDesignName(wp) &amp;&amp; (!ds.hasFormula())) {
                designMatchInfo = ds.getType() + ": " + ds.getName();
                return true; // no formula to check
            }

        }
        // if we're here we either match on name (title) or there wasn't one (formula only)
        if (ds.hasFormula()) {
            String fmla = ds.getFormula();
            if (matchesSelectFormula(session, fmla)) {
                designMatchInfo = ds.getType() + ": " + ds.getFormula();
                return true;
            }
        }
        return false;
    }

    public boolean wantDesignNoteType(Document Note) throws NotesException {
        boolean fProcessNote = false;
        forceNoteFormat = false;

        if (Note.hasItem("$ViewFormat")) {
            noteDescription = "View: " + Note.getItemValueString("$Title");
            designNoteType = "view";
            fProcessNote = true;
        }
        else if (Note.hasItem("IconBitmap")) {
            noteDescription = "Icon Note";
            designNoteType = "icon";
            fProcessNote = true;
        }
        else {
            String title = Note.getItemValueString("$Title");
            String flags = Note.getItemValueString("$Flags");
            if ((flags.indexOf("g") &gt;= 0) &amp;&amp; (flags.indexOf("K") &gt;= 0)) {
                noteDescription = "XPage: " + title + "; flags=" + flags;
                designNoteType = "xpage";
                fProcessNote = true;
            }
            else if ((flags.indexOf("g") &gt;= 0) &amp;&amp; (flags.indexOf(";") &gt;= 0)) {
                noteDescription = "Custom Control: " + title + "; flags=" + flags;
                designNoteType = "customcontrol";
                fProcessNote = true;
            }
            else if (flags.indexOf("i") &gt;= 0) {
                Item item = Note.getFirstItem("$ImageData");
                long itmSize = item.getValueLength();
                // fProcessNote = null != item &amp;&amp; itmSize &lt; 512;
                fProcessNote = true; // now that we have chunking all images sent unless restricted by selection...
                noteDescription = "Image " + title + "; size=" + itmSize + "; flags=" + flags;
                designNoteType = "imageresource";
            }
            else if (flags.indexOf("h") &gt;= 0 || flags.indexOf(".") &gt;= 0) {
                noteDescription = "JavaScript Lib: " + title + "; flags=" + flags;
                designNoteType = "jslib";
                fProcessNote = true;
                if (flags.indexOf(".") &gt;= 0) {
                    forceNoteFormat = true;
                }
            }
            else if ((flags.indexOf("g") &gt;= 0) &amp;&amp; title.startsWith("unp/")) {
                noteDescription = "File Resource: " + title + "; flags=" + flags;
                designNoteType = "fileresource";
                fProcessNote = true;
            }
            else if (flags.indexOf("=") &gt;= 0) {
                noteDescription = "CSS Resource: " + title + "; flags=" + flags;
                designNoteType = "css";
                fProcessNote = true;
            }
            else {
                fProcessNote = false;
                noteDescription = "Non-Replicating: " + title + "; flags=" + flags;
                designNoteType = "other";
            }

        }
        return fProcessNote;
    }

    private static String getXsl(boolean isDataXsl, SessionInfo sessInf) {
    	
    	String replicatorPath = null;
    	String targetDbPath = null;
		try {
			//replicatorPath = java.net.URLEncoder.encode(sessInf.getReplicator().getFilePath(), "UTF-8");
			//targetDbPath = java.net.URLEncoder.encode(sessInf.getTargetDbApiPath(), "UTF-8");
			replicatorPath = Pull.xmlEscape(sessInf.getReplicator().getFilePath());
			targetDbPath = Pull.xmlEscape(sessInf.getTargetDbApiPath().replace("\\", "/"));

		} catch (NotesException e) {
			// TODO Auto-generated catch block
			Pull.writeDebug("Error getting current replicator URL; " + e.getMessage());
			e.printStackTrace();
			throw new RuntimeException(e);
		}
    	
        String rtTemplate = ""; // not set if design el
        if (isDataXsl) {
            rtTemplate = "&lt;xsl:template match='dxl:item/dxl:richtext'&gt;" + "&lt;xsl:copy&gt;"
            // TODO assess rt handling w attach limit!
            // + "&lt;xsl:apply-templates select='@* | descendant::dxl:attachmentref' /&gt;" + "&lt;/xsl:copy&gt;"
                    + "&lt;xsl:apply-templates select='@*|node()' /&gt;" + "&lt;/xsl:copy&gt;" + "&lt;/xsl:template&gt;";
            if (sessInf.hasAttachmentFilters()) {

                if (!sessInf.getAttachmentFilters().contains(ATTACH_FILTER_SEND_ALL)) {

                    Object[] filters = sessInf.getAttachmentFilters().toArray();
                    rtTemplate += "&lt;xsl:template match=\"dxl:richtext//dxl:attachmentref[";

                    for (int i = 0; i &lt; filters.length; i++) {
                        String filter = "." + (String)filters[i];
                        rtTemplate += i &gt; 0 ? " and " : "";
                        rtTemplate +=
                                "not( substring(@name, string-length(@name) - string-length('" + filter + "') +1) = '" + filter
                                        + "')";
                    }
                    rtTemplate += "]\" /&gt;";
                }
            }
            else {
                // rtTemplate += "&lt;xsl:template match=\"dxl:richtext//dxl:attachmentref\" /&gt;";
            }
            Pull.writeDebug("*****************rtTemplate*****************");
            Pull.writeDebug(rtTemplate);
            Pull.writeDebug("********************************************");
        }
        return "&lt;?xml version='1.0'?&gt;"
                + "&lt;xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' xmlns:dxl='http://www.lotus.com/dxl' version='1.0'&gt;"
                // testing only, format the xml -- breaks replicator test TestAllCharacters!
                // + "&lt;xsl:output method='xml' indent='yes' /&gt; &lt;!-- Format xml --&gt;"
                + "&lt;xsl:template match='@*|node()'&gt;" + "&lt;xsl:copy&gt;"
                + "&lt;xsl:apply-templates select='@*|node()'/&gt;"
                + "&lt;/xsl:copy&gt;"
                + "&lt;/xsl:template&gt;"
                /*
                 * // strip content for testing, comment out for normal use + "&lt;xsl:template match='" + "dxl:note" + "|dxl:page" +
                 * "|dxl:frameset" + "|dxl:noteinfo" + "|dxl:imageresource" + "|dxl:view" + "|dxl:stylesheetresource" +
                 * "|dxl:document'&gt;" + " &lt;xsl:call-template name='attribonly' /&gt; " + "&lt;/xsl:template&gt;"
                 * 
                 * + "&lt;xsl:template name='attribonly'&gt;" + "&lt;xsl:copy&gt;" + "&lt;xsl:apply-templates select='@*'/&gt;" +
                 * "&lt;xsl:apply-templates select='dxl:noteinfo|dxl:modified' /&gt;" + "&lt;/xsl:copy&gt;" + "&lt;/xsl:template&gt;" // end strip
                 * content
                 */

                + "&lt;xsl:template match='dxl:actionbar'/&gt;"

                + rtTemplate
                
                //Supplemental PV3 template to replace richtext//filedata
                + "&lt;xsl:template match=\"dxl:item//dxl:filedata\"&gt;" + "&lt;xsl:copy&gt;"
                      + "&lt;xsl:apply-templates select='@*' /&gt;" 
                     + "&lt;xsl:attribute name='unpattachurl'&gt;"
                    + "yes"
//                     + "/" + replicatorPath + "/getAttachment.xsp?db=" + targetDbPath + "&amp;amp;documentId="
//                     + "&lt;xsl:value-of select='ancestor::dxl:document/dxl:noteinfo/@unid'&gt;&lt;/xsl:value-of&gt;" 
//                     + "&amp;amp;file="
//                     + "&lt;xsl:value-of select='../@name'&gt;&lt;/xsl:value-of&gt;" 
                      + "&lt;/xsl:attribute&gt;"
                      
                      + "&lt;xsl:text&gt;/" + replicatorPath + "/getAttachment.xsp?db=" + targetDbPath + "&amp;amp;documentId=&lt;/xsl:text&gt;"
                      + "&lt;xsl:value-of select='ancestor::dxl:document/dxl:noteinfo/@unid'&gt;&lt;/xsl:value-of&gt;" 
                      + "&lt;xsl:text&gt;&amp;amp;file=&lt;/xsl:text&gt;"
                      //+ "&lt;xsl:value-of select='../@name'&gt;&lt;/xsl:value-of&gt;" 
                      
                      + "&lt;/xsl:copy&gt;" 
                      + "&lt;/xsl:template&gt;"
                

                // copy only last revision &gt;&gt; dxl:datetime[last()]
                + "&lt;xsl:template match='dxl:document/dxl:revisions'&gt;" + "&lt;xsl:copy&gt;"
                + "&lt;xsl:apply-templates select='@*|dxl:datetime[last()]'/&gt;" + "&lt;/xsl:copy&gt;" + "&lt;/xsl:template&gt;"

                + ((isDataXsl) ? "&lt;xsl:template match='dxl:item[dxl:rawitemdata]' /&gt;" : "")
                + "&lt;xsl:template match='dxl:sharedactions'/&gt;" + "&lt;xsl:template match='dxl:acl'/&gt;"
                + "&lt;xsl:template match='dxl:item[starts-with(@name, \"$Class\")]' /&gt;"
                + "&lt;xsl:template match='dxl:code[dxl:lotusscript]' /&gt;" + "&lt;xsl:template match='dxl:globals' /&gt;"
                + "&lt;/xsl:stylesheet&gt;";
    }

    public boolean wantNote(boolean skipPurges) throws NotesException {
        if (si.isForceUpgrade() &amp;&amp; (!si.isFirstPull())) {
            if (!wantNoteForUpgrade()) {
                return false;
            }
        }
        if (skipPurges) {
            return (wantType() &amp;&amp; matchesFormula()); // we only want things that match if we're skip...
        }
        else {
            return wantType();
        }
    }

    private boolean wantNoteForUpgrade() throws NotesException {
    	if(IReplicationNote.TYPE_DELETION == type){
    		return true;  //THE LS/API code date checks deletions and only includes if they are after sinceTime...
    	}
    	
        if (0 &lt;= doc.getLastModified().timeDifferenceDouble(si.getSinceNotes())) {
//            Pull.writeDebug(type + "  IS MOD since pull, sending: " + id + ";  FORM: " + doc.getItemValueString("Form")
//                    + "; $Flags: " + doc.getItemValueString("$Flags")
//                    + " doc Last Mod: " + doc.getLastModified().getLocalTime() 
//                    + " sinceNotes: " + si.getSinceNotes().getLocalTime()
//                    + " tdd: " + doc.getLastModified().timeDifferenceDouble(si.getSinceNotes())
//                    + "\n lastModJava: " + doc.getLastModified().toJavaDate().getTime() 
//                    + " since as java" + si.getSinceNotes().toJavaDate().getTime()
//            );
            return true;
        }
        
        if (IReplicationNote.TYPE_DATA == type) {
            Vector itms = doc.getItems();
            if (!itms.isEmpty()) {
                for (int i = 0; i &lt; itms.size(); i++) {
                    Item itm = (Item)itms.elementAt(i);
                    if (Item.RICHTEXT == itm.getType()) {
                        Pull.writeDebug("Resending document required for upgrade: " + id + ";  FORM: " + doc.getItemValueString("Form"));
                        return true;
                    }
                }
            }

            si.upgradeDataNoteSkipped();
//            Pull.writeDebug(type + " NOT needing update: " + id + ";  FORM: " + doc.getItemValueString("Form") + "; $Flags: "
//                    + doc.getItemValueString("$Flags"));
        }
        else {
        	si.upgradeDesignNoteSkipped();
//            Pull.writeDebug(type + "  DSGN NOT needing update: " + id + ";  $Title: " + doc.getItemValueString("$Title")
//                    + "; $Flags: " + doc.getItemValueString("$Flags"));
        }

        return false;
    }

	public String getTitle() throws NotesException {
		if(isNoteLoaded()){
			return doc.getItemValueString("$Title");
		}
		return null;
	}

}
</java><java name='com/teamstudio/unplugged/libs/pv4/ReplicationNote.java'>package com.teamstudio.unplugged.libs.pv4;

import java.io.StringReader;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Vector;

import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import lotus.domino.Database;
import lotus.domino.Document;
import lotus.domino.DxlExporter;
import lotus.domino.EmbeddedObject;
import lotus.domino.Item;
import lotus.domino.NotesException;
import lotus.domino.RichTextItem;
import lotus.domino.Session;

import com.teamstudio.unplugged.libs.DesignSelect;
import com.teamstudio.unplugged.libs.FieldSelect;
import com.teamstudio.unplugged.libs.IReplicationNote;
import com.teamstudio.unplugged.libs.Logger;
import com.teamstudio.unplugged.libs.PVObjectFactory;
import com.teamstudio.unplugged.libs.Pull;
import com.teamstudio.unplugged.libs.SessionInfo;
import com.teamstudio.unplugged.libs.TeamstudioException;
import com.teamstudio.unplugged.libs.WildcardPattern;

public class ReplicationNote implements IReplicationNote {
    public static int FILE_FORMAT = 3;
    private static final String ERRMSG_DXLEXPORTERRLOGMSG =
            "** DXL Export Error: DXLExporter.exportDxl() returned the following error: ";
    private static final String ERRMSG_DXLEXPORTFAILEDCHECKLOG =
            "DXL Exporter error. Check the Unplugged server log Debugging Messages for details.";
    private static final String ERR_ATTACH_FILTER_FAIL_MSG = "Attempt to filter attachments failed!";
    private static final int ERR_ATTACH_FILTER_FAIL = 9899;
    private static final String ATTACH_FILTER_SEND_ALL = "*.*";

    private static Templates cachedXSLT;
    private static Templates cachedDocumentXSLT;
    private int type;
    private String id;
    private Document doc;
    private String noteDescription = "Not set";
    private boolean wantType;
    private boolean matchesFormula;
    private boolean forceNoteFormat;
    private SessionInfo si;
    private boolean hasError = false;
    private String designNoteType;
    private String designMatchInfo;
    private int currentClientFormat;

    public boolean hasError() {
        return hasError;
    }

    public String getTypeName() {
        String stype = "Unknown";
        switch (type) {
        case TYPE_DATA:
            stype = "DATA";
            break;
        case TYPE_DESIGN:
            stype = "DSGN";
            break;
        case TYPE_DELETION:
            stype = "DEL";
            break;
        }
        return stype;
    }

    public String toString() {
        return getTypeName() + ": " + id + "; Matches: " + matchesFormula
                + ((null != designMatchInfo) ? (" (" + designMatchInfo + ")") : "") + ";  " + noteDescription;
    }

    public static int getTypeFromFirstChar(String ID) {
        int retval = TYPE_UNKNOWN;
        char first = ID.charAt(0);
        switch (first) {
        case 'z':
            retval = TYPE_DESIGN;
            break;
        case 'x':
            retval = TYPE_DELETION;
            break;
        case 'y':
            retval = TYPE_DATA;
            break;

        case 'u':
            retval = TYPE_UNKNOWN;
            break;
        }
        return retval;
    }

    public ReplicationNote(String IDWithTypePrefix, SessionInfo SI, int currentFormat) {
        super();
        if ((null == IDWithTypePrefix) || (1 &gt; IDWithTypePrefix.length())) {
            return;
        }
        type = getTypeFromFirstChar(IDWithTypePrefix);
        id = IDWithTypePrefix.substring(1);
        si = SI;
        currentClientFormat = currentFormat; // Needed to decide what data needs resend...
    }

    public boolean matchesSelectFormula(Session session, String sFmla) {
        Object doesMatch;
        try {
            doesMatch = session.evaluate(sFmla, doc).elementAt(0);
            if (doesMatch instanceof Double &amp;&amp; ((Double)doesMatch).doubleValue() != 0) {
                return true;
            }
            return false;

        }
        catch (NotesException e) {
            noteDescription += " FORMULA EVAL FAILED!";
            return false;
        }
    }

    public boolean loadDoc(Session session, Database db) throws NotesException {
        if (TYPE_DELETION == type) {
            noteDescription = "Deletion Stub";
            wantType = true;
            matchesFormula = true;
            return true;
        }
        else {
            try {
                doc = db.getDocumentByID(id);
            }
            catch (NotesException ex) {
                ex.printStackTrace();
                noteDescription = "Error loading note: " + ex.id + ":" + ex.text;
                hasError = true;
            }
            if (null == doc) {
                if (!hasError) { // don't overwrite if error included...
                    noteDescription = "Not loaded; Reader field protected or no longer available.";
                }
                return false;
            }
            else {
                if (TYPE_UNKNOWN == type) { // if the type was unknown when created, find type here.
                    if (doc.hasItem("$Title") &amp;&amp; doc.hasItem("$Flags")) {
                        type = TYPE_DESIGN;
                    }
                    else {
                        type = TYPE_DATA;
                    }
                }

                // check selection formulas
                if (TYPE_DESIGN == type) {
                    wantType = wantDesignNoteType(doc);
                    if (wantType) {
                        matchesFormula = (!si.hasDesignSelect()) ? true : matchesDesignSelection(session, si);
                    }
                }
                else {
                    wantType = true;
                    noteDescription = "Form: " + doc.getItemValueString("Form");
                    matchesFormula = (!si.hasSelect()) ? true : matchesSelectFormula(session, si.getSelectFormula());
                }

                return true;
            }
        }
    }

    public boolean wantType() {
        return wantType;
    }

    public boolean matchesFormula() {
        return matchesFormula;
    }

    private boolean stripUnwanted(Session session, ArrayList filters) throws Exception {
        if (filters.contains(ATTACH_FILTER_SEND_ALL)) {
            return true;
        }

        Vector v = session.evaluate("@AttachmentNames", doc);

        if (!v.isEmpty()) {
            for (int i = 0; i &lt; v.size(); i++) {
                String sAttachment = (String)v.elementAt(i);
                if (!sAttachment.equals("")) {
                    String sExt = sAttachment.substring(sAttachment.lastIndexOf('.') + 1);
                    if (!filters.contains(sExt.toLowerCase())) {
                        EmbeddedObject eo = doc.getAttachment(sAttachment);
                        eo.remove();
                    }
                }
            }
        }

        return true;
    }

    public String getNoteDxl(Session session, DxlExporter ex, Logger log) throws Exception {

        String noteXml = "";
        boolean needSendPurge = true;
        String unid = (TYPE_DELETION == type) ? id : doc.getUniversalID();
        HashSet deviceUnids = si.getDeviceUnidMap();
        if (null != deviceUnids) {
            if (!deviceUnids.contains(unid)) {
                needSendPurge = false;
            }
        }
        if (TYPE_DELETION == type) {
            if (needSendPurge) {
                noteXml = "&lt;tms:deletionStub unid='" + unid + "' /&gt;"; // Note that ls ag won't return del stubs if new pull
            }
            else {
                // noteXml = "&lt;tms:ignoredstub unid='" + unid + "' /&gt;";
            }
        }
        else {
            boolean omitAttachments = true;

            if (isNoteLoaded()) {

                if (wantType) {
                    if (matchesFormula) {
                        boolean forceNoteFormatSetting = ex.getForceNoteFormat();
                        ex.setForceNoteFormat(forceNoteFormat);

                        if (TYPE_DATA == type) {
                            if (si.hasAttachmentFilters()) {
                                omitAttachments = false;
                                ArrayList filters = si.getAttachmentFilters();
                                if (!stripUnwanted(session, filters)) {
                                    throw new TeamstudioException(ERR_ATTACH_FILTER_FAIL, ERR_ATTACH_FILTER_FAIL_MSG);
                                }
                            }

                            // CONVERT MIME for RT handling
                            // and process field selection...
                            String sForm = doc.getItemValueString("Form");
                            Vector items = doc.getItems();
                            for (int i = 0; i &lt; items.size(); i++) {
                                Item item = (Item)items.get(i);
                                if (wantItem(session, sForm, item)) { // TODO aliases on forms
                                    if (item instanceof RichTextItem) {
                                        RichTextItem rti = (RichTextItem)item;
                                        rti.appendText("");
                                        rti.update();
                                        rti.compact();
                                    }
                                }
                                else {
                                    // if (null != log) {
                                    // log.DebugWrite("Skipping item" + item.getName());
                                    // }
                                    item.remove(); // don't let the exporter have it if it's filtered
                                }
                            }

                            // we set exporter to desired settings then revert to defaults
                            boolean miscFileObjsSetting = ex.getOmitMiscFileObjects();
                            boolean richtextAttachmentsSetting = ex.getOmitRichtextAttachments();
                            boolean pictsSetting = ex.getOmitRichtextPictures();
                            boolean bmpSetting = ex.getConvertNotesBitmapsToGIF();
                            int rtOptionSetting = ex.getRichTextOption();

                            ex.setOmitMiscFileObjects(omitAttachments);
                            ex.setOmitRichtextAttachments(omitAttachments);
                            ex.setOmitRichtextPictures(false);
                            ex.setConvertNotesBitmapsToGIF(true);
                            ex.setRichTextOption(DxlExporter.DXLRICHTEXTOPTION_DXL);

                            try {
                                noteXml = transformXML(ex.exportDxl(doc));
                            }
                            catch (Exception e) {
                                if (null != log) {
                                    log.DebugWrite("\n" + ERRMSG_DXLEXPORTERRLOGMSG);
                                    log.DebugWrite(ex.getLog() + "\n");
                                }
                                throw new TeamstudioException(ERRMSG_DXLEXPORTFAILEDCHECKLOG, e);
                            }

                            ex.setOmitMiscFileObjects(miscFileObjsSetting); // reset in case there's ever another function that
                            // expects original settings
                            ex.setOmitRichtextAttachments(richtextAttachmentsSetting);
                            ex.setOmitRichtextPictures(pictsSetting);
                            ex.setConvertNotesBitmapsToGIF(bmpSetting);
                            ex.setRichTextOption(rtOptionSetting);

                        }
                        else {
                            // design
                            try {
                                noteXml = transformXML(ex.exportDxl(doc));
                            }
                            catch (Exception e) {
                                if (null != log) {
                                    log.DebugWrite("\n" + ERRMSG_DXLEXPORTERRLOGMSG);
                                    log.DebugWrite(ex.getLog() + "\n");
                                }
                                throw new TeamstudioException(ERRMSG_DXLEXPORTFAILEDCHECKLOG, e);
                            }
                        }

                        ex.setForceNoteFormat(forceNoteFormatSetting);

                        if (noteXml.startsWith("&lt;?xml version=")) {
                            noteXml = noteXml.substring(noteXml.indexOf("?&gt;") + "?&gt;".length());
                        }

                    }
                    else { // purge
                        if (needSendPurge) {
                            noteXml = "&lt;tms:purge unid='" + unid + "' /&gt;";
                        }
                        else {
                            // noteXml = "&lt;tms:ignoredpurge unid='" + unid + "' /&gt;";
                        }
                    }
                }

            }

        }
        return noteXml;
    }

    private boolean wantItem(Session session, String formName, Item item) throws NotesException {
        if (!si.hasFieldSelect()) {
            return true;
        }
        String itemName = item.getName().toLowerCase();
        if (itemName.equals("form") || itemName.startsWith("$")) {
            return true;
        }
        Vector formNames = new Vector();
        formNames.add(formName);
        Vector fieldNames = new Vector();
        fieldNames.add(itemName);

        ArrayList fieldSelects = si.getFieldSelectElements();
        Iterator iter = fieldSelects.iterator();
        while (iter.hasNext()) {
            FieldSelect fsForm = (FieldSelect)iter.next();
            if (matchesDesignSelect(session, formNames, fsForm)) {

                if (fsForm.hasKnownMatch(itemName)) {
                    return fsForm.getKnownMatch(itemName);
                }
                else {

                    ArrayList fields = fsForm.getChildren();
                    Iterator iterF = fields.iterator();
                    while (iterF.hasNext()) {
                        FieldSelect fsFld = (FieldSelect)iterF.next();
                        if (matchesDesignSelect(session, fieldNames, fsFld)) {
                            fsForm.addKnownMatch(itemName, fsFld.isInclude());
                            return fsFld.isInclude();
                        }
                        else {
                            if (fsForm.isExcludeOnly()) {
                                fsForm.addKnownMatch(itemName, true);
                                return true;
                            }
                        }
                    }
                }
            }
        }

        return false;
    }

    public void releaseDoc() throws NotesException {
        if (null != doc) {
            doc.recycle();
            doc = null;
        }
    }

    public boolean isNoteLoaded() {
        return (null != doc);
    }

    public int getType() {
        return type;
    }

    public void setType(int type) {
        this.type = type;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    private String transformXML(String xml) throws Exception {
        StringWriter writer = new StringWriter();
        Source xmlSource = new StreamSource(new StringReader(xml));
        Result result = new StreamResult(writer);
        Transformer trans = null;
        if (TYPE_DATA == type) {
            if (null == cachedDocumentXSLT) {
                Source xsltSource = new StreamSource(new StringReader(getXsl(true, si)));
                TransformerFactory transFact =
                        TransformerFactory.newInstance("org.apache.xalan.processor.TransformerFactoryImpl", null);
                cachedDocumentXSLT = transFact.newTemplates(xsltSource);
            }
            trans = cachedDocumentXSLT.newTransformer();
        }
        else {
            if (null == cachedXSLT) {
                Source xsltSource = new StreamSource(new StringReader(getXsl(false, si)));
                TransformerFactory transFact =
                        TransformerFactory.newInstance("org.apache.xalan.processor.TransformerFactoryImpl", null);
                cachedXSLT = transFact.newTemplates(xsltSource);
            }
            trans = cachedXSLT.newTransformer();
        }

        trans.transform(xmlSource, result);
        return writer.toString();
    }

    public String getNoteDescription() {
        return noteDescription;
    }

    private boolean matchesNameOrAlias(Vector vals, WildcardPattern wp) {
        for (int i = 0; i &lt; vals.size(); i++) { // loop all values (title and alias)
            String title = (String)vals.get(i);
            if (-1 == title.indexOf("|")) { // un-aliased
                if (wp.matches(title)) {
                    return true;
                }
            }
            else { // aliased
                String[] arrTitles = title.split("\\|");
                for (int y = 0; y &lt; arrTitles.length; y++) {
                    if (wp.matches(arrTitles[y])) {
                        return true;
                    }
                }
            }
        }
        return false; // no match
    }

    private boolean matchesDesignSelection(Session session, SessionInfo si) throws NotesException {

        if (!si.hasDesignSelect() || ("icon".equals(designNoteType))) {
            return true; // nothing to do.
        }

        Map designSelects = si.getDesignSelectElements();

        if ((!designSelects.containsKey(designNoteType)) &amp;&amp; (!designSelects.containsKey("all"))) {
            return true; // no select applies to this type so note should be sent.
        }

        Iterator iter = null;

        Vector titles = doc.getItemValue("$Title");

        // check typed selects if any
        if (designSelects.containsKey(designNoteType)) {
            iter = ((ArrayList)designSelects.get(designNoteType)).iterator();
            while (iter.hasNext()) {
                DesignSelect ds = (DesignSelect)iter.next();
                if (matchesDesignSelect(session, titles, ds)) {
                    return true;
                }
            }
        }

        // if no typed selects match, check globals
        if (designSelects.containsKey("all")) {
            iter = ((ArrayList)designSelects.get("all")).iterator();
            while (iter.hasNext()) {
                DesignSelect ds = (DesignSelect)iter.next();
                if (matchesDesignSelect(session, titles, ds)) {
                    return true;
                }
            }
        }

        // if we're here, we did apply selects but didn't match so don't send note.
        return false;

    }

    private boolean matchesDesignSelect(Session session, Vector names, DesignSelect ds) throws NotesException {
        // it applies to the current note
        if (ds.hasName()) {
            WildcardPattern wp = ds.getWc();
            if (matchesNameOrAlias(names, wp) &amp;&amp; (!ds.hasFormula())) {
                designMatchInfo = ds.getType() + ": " + ds.getName();
                return true; // no formula to check
            }

        }
        // if we're here we either match on name (title) or there wasn't one (formula only)
        if (ds.hasFormula()) {
            String fmla = ds.getFormula();
            if (matchesSelectFormula(session, fmla)) {
                designMatchInfo = ds.getType() + ": " + ds.getFormula();
                return true;
            }
        }
        return false;
    }

    public boolean wantDesignNoteType(Document Note) throws NotesException {
        boolean fProcessNote = false;
        forceNoteFormat = false;

        if (Note.hasItem("$ViewFormat")) {
            noteDescription = "View: " + Note.getItemValueString("$Title");
            designNoteType = "view";
            fProcessNote = true;
        }
        else if (Note.hasItem("IconBitmap")) {
            noteDescription = "Icon Note";
            designNoteType = "icon";
            fProcessNote = true;
        }
        else {
            String title = Note.getItemValueString("$Title");
            String flags = Note.getItemValueString("$Flags");
            if ((flags.indexOf("g") &gt;= 0) &amp;&amp; (flags.indexOf("K") &gt;= 0)) {
                noteDescription = "XPage: " + title + "; flags=" + flags;
                designNoteType = "xpage";
                fProcessNote = true;
            }
            else if ((flags.indexOf("g") &gt;= 0) &amp;&amp; (flags.indexOf(";") &gt;= 0)) {
                noteDescription = "Custom Control: " + title + "; flags=" + flags;
                designNoteType = "customcontrol";
                fProcessNote = true;
            }
            else if (flags.indexOf("i") &gt;= 0) {
                Item item = Note.getFirstItem("$ImageData");
                long itmSize = item.getValueLength();
                // fProcessNote = null != item &amp;&amp; itmSize &lt; 512;
                fProcessNote = true; // now that we have chunking all images sent unless restricted by selection...
                noteDescription = "Image " + title + "; size=" + itmSize + "; flags=" + flags;
                designNoteType = "imageresource";
            }
            else if (flags.indexOf("h") &gt;= 0 || flags.indexOf(".") &gt;= 0) {
                noteDescription = "JavaScript Lib: " + title + "; flags=" + flags;
                designNoteType = "jslib";
                fProcessNote = true;
                if (flags.indexOf(".") &gt;= 0) {
                    forceNoteFormat = true;
                }
            }
            else if ((flags.indexOf("g") &gt;= 0) &amp;&amp; title.startsWith("unp/")) {
                noteDescription = "File Resource: " + title + "; flags=" + flags;
                designNoteType = "fileresource";
                fProcessNote = true;
            }
            else if (flags.indexOf("=") &gt;= 0) {
                noteDescription = "CSS Resource: " + title + "; flags=" + flags;
                designNoteType = "css";
                fProcessNote = true;
            }
            else {
                fProcessNote = false;
                noteDescription = "Non-Replicating: " + title + "; flags=" + flags;
                designNoteType = "other";
            }

        }
        return fProcessNote;
    }

    private static String getXsl(boolean isDataXsl, SessionInfo sessInf) {

        String replicatorPath = null;
        String targetDbPath = null;
        try {
            // replicatorPath = java.net.URLEncoder.encode(sessInf.getReplicator().getFilePath(), "UTF-8");
            // targetDbPath = java.net.URLEncoder.encode(sessInf.getTargetDbApiPath(), "UTF-8");
            replicatorPath = Pull.xmlEscape(sessInf.getReplicator().getFilePath());
            targetDbPath = Pull.xmlEscape(sessInf.getTargetDbApiPath().replace("\\", "/"));

        }
        catch (NotesException e) {
            Pull.writeDebug("Error getting current replicator URL; " + e.getMessage());
            e.printStackTrace();
            throw new RuntimeException(e);
        }

        String rtTemplate = ""; // not set if design el
        if (isDataXsl) {
            rtTemplate = "&lt;xsl:template match='dxl:item/dxl:richtext'&gt;" + "&lt;xsl:copy&gt;"
            // + "&lt;xsl:apply-templates select='@* | descendant::dxl:attachmentref' /&gt;" + "&lt;/xsl:copy&gt;"
                    + "&lt;xsl:apply-templates select='@*|node()' /&gt;" + "&lt;/xsl:copy&gt;" + "&lt;/xsl:template&gt;";
            if (sessInf.hasAttachmentFilters()) {

                if (!sessInf.getAttachmentFilters().contains(ATTACH_FILTER_SEND_ALL)) {

                    Object[] filters = sessInf.getAttachmentFilters().toArray();
                    rtTemplate += "&lt;xsl:template match=\"dxl:richtext//dxl:attachmentref[";

                    for (int i = 0; i &lt; filters.length; i++) {
                        String filter = "." + (String)filters[i];
                        rtTemplate += i &gt; 0 ? " and " : "";
                        rtTemplate +=
                                "not( substring(@name, string-length(@name) - string-length('" + filter + "') +1) = '" + filter
                                        + "')";
                    }
                    rtTemplate += "]\" /&gt;";
                }
            }
            else {
                // rtTemplate += "&lt;xsl:template match=\"dxl:richtext//dxl:attachmentref\" /&gt;";
            }
            Pull.writeDebug("*****************rtTemplate*****************");
            Pull.writeDebug(rtTemplate);
            Pull.writeDebug("********************************************");
        }
        return "&lt;?xml version='1.0'?&gt;"
                + "&lt;xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' xmlns:dxl='http://www.lotus.com/dxl' version='1.0'&gt;"
                // testing only, format the xml -- breaks replicator test TestAllCharacters!
                // + "&lt;xsl:output method='xml' indent='yes' /&gt; &lt;!-- Format xml --&gt;"
                + "&lt;xsl:template match='@*|node()'&gt;" + "&lt;xsl:copy&gt;" + "&lt;xsl:apply-templates select='@*|node()'/&gt;" + "&lt;/xsl:copy&gt;"
                + "&lt;/xsl:template&gt;"
                /*
                 * // strip content for testing, comment out for normal use + "&lt;xsl:template match='" + "dxl:note" + "|dxl:page" +
                 * "|dxl:frameset" + "|dxl:noteinfo" + "|dxl:imageresource" + "|dxl:view" + "|dxl:stylesheetresource" +
                 * "|dxl:document'&gt;" + " &lt;xsl:call-template name='attribonly' /&gt; " + "&lt;/xsl:template&gt;"
                 * 
                 * + "&lt;xsl:template name='attribonly'&gt;" + "&lt;xsl:copy&gt;" + "&lt;xsl:apply-templates select='@*'/&gt;" +
                 * "&lt;xsl:apply-templates select='dxl:noteinfo|dxl:modified' /&gt;" + "&lt;/xsl:copy&gt;" + "&lt;/xsl:template&gt;" // end strip
                 * content
                 */

                + "&lt;xsl:template match='dxl:actionbar'/&gt;"

                + rtTemplate

                // Supplemental PV3 template to replace richtext//filedata
                + "&lt;xsl:template match=\"dxl:item//dxl:filedata\"&gt;"
                + "&lt;xsl:copy&gt;"
                + "&lt;xsl:apply-templates select='@*' /&gt;"
                + "&lt;xsl:attribute name='unpattachurl'&gt;"
                + "yes"
                // + "/" + replicatorPath + "/getAttachment.xsp?db=" + targetDbPath + "&amp;amp;documentId="
                // + "&lt;xsl:value-of select='ancestor::dxl:document/dxl:noteinfo/@unid'&gt;&lt;/xsl:value-of&gt;"
                // + "&amp;amp;file="
                // + "&lt;xsl:value-of select='../@name'&gt;&lt;/xsl:value-of&gt;"
                + "&lt;/xsl:attribute&gt;"

                + "&lt;xsl:text&gt;/"
                + replicatorPath
                + "/getAttachment.xsp?db="
                + targetDbPath
                + "&amp;amp;documentId=&lt;/xsl:text&gt;"
                + "&lt;xsl:value-of select='ancestor::dxl:document/dxl:noteinfo/@unid'&gt;&lt;/xsl:value-of&gt;"
                + "&lt;xsl:text&gt;&amp;amp;file=&lt;/xsl:text&gt;"
                // + "&lt;xsl:value-of select='../@name'&gt;&lt;/xsl:value-of&gt;"

                + "&lt;/xsl:copy&gt;"
                + "&lt;/xsl:template&gt;"

                // copy only last revision &gt;&gt; dxl:datetime[last()]
                + "&lt;xsl:template match='dxl:document/dxl:revisions'&gt;"
                + "&lt;xsl:copy&gt;"
                + "&lt;xsl:apply-templates select='@*|dxl:datetime[last()]'/&gt;"
                + "&lt;/xsl:copy&gt;"
                + "&lt;/xsl:template&gt;"

                + ((isDataXsl) ? "&lt;xsl:template match='dxl:item[dxl:rawitemdata]' /&gt;" : "")
                + "&lt;xsl:template match='dxl:sharedactions'/&gt;"
                + "&lt;xsl:template match='dxl:acl'/&gt;"
                + "&lt;xsl:template match='dxl:item[starts-with(@name, \"$Class\")]' /&gt;"
                + "&lt;xsl:template match='dxl:code[dxl:lotusscript]' /&gt;"
                + "&lt;xsl:template match='dxl:globals' /&gt;"
                + "&lt;/xsl:stylesheet&gt;";
    }

    public boolean wantNote(boolean skipPurges) throws NotesException {
        if (si.isForceUpgrade() &amp;&amp; (!si.isFirstPull())) {
            if (!wantNoteForUpgrade()) {
                return false;
            }
        }
        if (skipPurges) {
            return (wantType() &amp;&amp; matchesFormula()); // we only want things that match if we're skip...
        }
        else {
            return wantType();
        }
    }

    private boolean wantNoteForUpgrade() throws NotesException {
        if (IReplicationNote.TYPE_DELETION == type) {
            return true; // THE LS/API code date checks deletions and only includes if they are after sinceTime...
        }

        if (0 &lt;= doc.getLastModified().timeDifferenceDouble(si.getSinceNotes())) {
            // Pull.writeDebug(type + "  IS MOD since pull, sending: " + id + ";  FORM: " + doc.getItemValueString("Form")
            // + "; $Flags: " + doc.getItemValueString("$Flags")
            // + " doc Last Mod: " + doc.getLastModified().getLocalTime()
            // + " sinceNotes: " + si.getSinceNotes().getLocalTime()
            // + " tdd: " + doc.getLastModified().timeDifferenceDouble(si.getSinceNotes())
            // + "\n lastModJava: " + doc.getLastModified().toJavaDate().getTime()
            // + " since as java" + si.getSinceNotes().toJavaDate().getTime()
            // );
            return true;
        }

        if (IReplicationNote.TYPE_DATA == type) {
            if (si.hasFieldSelect()) {
                return true;
            }
            if (3 &gt; PVObjectFactory.getInstance().getCurrentClientFormat()) { // if it's in an older format than pv3 (separate
                                                                              // attachments)
                Vector itms = doc.getItems();
                if (!itms.isEmpty()) {
                    for (int i = 0; i &lt; itms.size(); i++) {
                        Item itm = (Item)itms.elementAt(i);
                        if (Item.RICHTEXT == itm.getType()) {
                            Pull.writeDebug("Resending document required for upgrade: " + id + ";  FORM: "
                                    + doc.getItemValueString("Form"));
                            return true;
                        }
                    }
                }
            }

            si.upgradeDataNoteSkipped();
            // Pull.writeDebug(type + " NOT needing update: " + id + ";  FORM: " + doc.getItemValueString("Form") + "; $Flags: "
            // + doc.getItemValueString("$Flags"));
        }
        else {
            si.upgradeDesignNoteSkipped();
            // Pull.writeDebug(type + "  DSGN NOT needing update: " + id + ";  $Title: " + doc.getItemValueString("$Title")
            // + "; $Flags: " + doc.getItemValueString("$Flags"));
        }

        return false;
    }

    public String getTitle() throws NotesException {
        if (isNoteLoaded()) {
            return doc.getItemValueString("$Title");
        }
        return null;
    }

}
</java></javaproject></code>
<item name='$JavaCompilerSource'><text>1.3</text></item>
<item name='$JavaCompilerTarget'><text>1.2</text></item>
<item name='$POID'><datetime dst='true'>20130501T151423,73-04</datetime></item></scriptlibrary>

